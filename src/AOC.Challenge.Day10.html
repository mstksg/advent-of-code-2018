<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="">{-# LANGUAGE QuasiQuotes #-}

-- |
-- Module      : AOC.Challenge.Day10
-- Copyright   : (c) Justin Le 2018
-- License     : BSD3
--
-- Maintainer  : justin@jle.im
-- Stability   : experimental
-- Portability : non-portable
--
-- Day 10.  See &quot;AOC.Solver&quot; for the types used in this module!

module AOC.Challenge.Day10 (
    day10a
  , day10b
  ) where

import           AOC.Common     (clearOut)
import           AOC.Solver     ((:~&gt;)(..))
import           Control.Monad  (guard)
import           Data.Bifunctor (second)
import           Data.Char      (isDigit)
import           Data.Foldable  (toList, foldMap)
import           Data.List      (unfoldr, uncons)
import           Data.Map       (Map)
import           Data.Maybe     (catMaybes)
import           Data.Semigroup (Min(..), Max(..))
import           Data.Set       (Set)
import           Linear         (V2(..))
import           Text.Heredoc   (here)
import qualified Data.Map       as M
import qualified Data.Set       as S

type Point = V2 Int

simulate
    :: [Point]        -- ^ velocities
    -&gt; [Point]        -- ^ points
    -&gt; [Point]        -- ^ new points
simulate = zipWith (+)

boundingBox :: [Point] -&gt; V2 Point
boundingBox ps = V2 xMin yMin `V2` V2 xMax yMax
  where
    (Min xMin, Min yMin, Max xMax, Max yMax) = flip foldMap ps $ \(V2 x y) -&gt;
        (Min x, Min y, Max x, Max y)

clusterArea :: [Point] -&gt; Int
clusterArea (boundingBox -&gt; V2 mins maxs) = product $ maxs - mins

findWord
    :: [Point]            -- ^ velocities
    -&gt; [Point]            -- ^ points
    -&gt; (Set Point, Int)   -- ^ points in word, and # of iterations
findWord vs xs0 = go 0 (clusterArea xs0) xs0
  where
    go :: Int -&gt; Int -&gt; [Point] -&gt; (Set Point, Int)
    go !i !area !xs
        | area' &gt; area = (S.fromList xs, i)
        | otherwise    = go (i + 1) area' xs'
      where
        xs'   = simulate vs xs
        area' = clusterArea xs'

day10a :: ([Point], [Point]) :~&gt; Set Point
day10a = MkSol
    { sParse = fmap unzip . traverse parsePoint . lines
    , sShow  = parseResult
    , sSolve = Just . fst . uncurry findWord
    }

day10b :: ([Point], [Point]) :~&gt; Int
day10b = MkSol
    { sParse = fmap unzip . traverse parsePoint . lines
    , sShow  = show
    , sSolve = Just . snd . uncurry findWord
    }

-- | Old solution: Display the points as ASCII plot
_display :: Set Point -&gt; String
_display ps = unlines [ [ if V2 x y `S.member` ps then '#' else '.'
                       | x &lt;- [xMin .. xMax]
                       ]
                     | y &lt;- [yMin .. yMax]
                     ]
  where
    V2 xMin yMin `V2` V2 xMax yMax = boundingBox (toList ps)

-- | New solution: Parse the set of points into a string, based on
-- 'letterforms'.
parseResult :: Set Point -&gt; String
parseResult ps = case M.lookup letter letterMap of
    Nothing -&gt; []
    Just c  -&gt; c : parseResult rest
  where
    origin `V2` _  = boundingBox (toList ps)
    shiftedPs      = subtract origin `S.map` ps
    (letter, rest) = S.partition (\(V2 x y) -&gt; x &lt; 6 &amp;&amp; y &lt; 10) shiftedPs

parsePoint :: String -&gt; Maybe (Point, Point)
parsePoint xs = case map read . words . clearOut p $ xs of
    [x,y,vx,vy] -&gt; Just (V2 vx vy, V2 x y)
    _           -&gt; Nothing
  where
    p '-' = False
    p c   = not $ isDigit c

-- | A map of a set of &quot;on&quot; points (for a 6x10 grid) to the letter
-- they represent
letterMap :: Map (Set Point) Char
letterMap = M.fromList
          . unfoldr (uncurry peel)
          . second (filter (not . null) . lines)
          $ letterforms
  where
    peel :: String -&gt; [String] -&gt; Maybe ((Set Point, Char), (String, [String]))
    peel cs ls = do
      (d,ds) &lt;- uncons cs
      let (m,ms) = unzip . map (splitAt 6) $ ls
          pointMap = S.fromList
                   . foldMap catMaybes
                   . zipWith (\j -&gt; zipWith (\i c -&gt; V2 i j &lt;$ guard (c == '#'))
                                            [0..]
                             )
                             [0..]
                   $ m
      pure ((pointMap, d), (ds, ms))

-- | All known letterforms.  Based on
-- &lt;https://gist.github.com/usbpc/5fa0be48ad7b4b0594b3b8b029bc47b4&gt;.
letterforms :: (String, String)
letterforms = (&quot;ABCEFGHJKLNPRXZ&quot;,[here|
..##..#####..####.############.####.#....#...####....##.....#....######.#####.#....#######
.#..#.#....##....##.....#.....#....##....#....#.#...#.#.....##...##....##....##....#.....#
</span><span class="hs-cpp">#....##....##.....#.....#.....#.....#....#....#.#..#..#.....##...##....##....#.#..#......#
#....##....##.....#.....#.....#.....#....#....#.#.#...#.....#.#..##....##....#.#..#.....#.
#....######.#.....#####.#####.#.....######....#.##....#.....#.#..######.#####...##.....#..
#######....##.....#.....#.....#..####....#....#.##....#.....#..#.##.....#..#....##....#...
#....##....##.....#.....#.....#....##....#....#.#.#...#.....#..#.##.....#...#..#..#..#....
#....##....##.....#.....#.....#....##....##...#.#..#..#.....#...###.....#...#..#..#.#.....
#....##....##....##.....#.....#...###....##...#.#...#.#.....#...###.....#....##....##.....
#....######..####.#######......###.##....#.###..#....########....##.....#....##....#######
</span><span class="hs-special">|]</span><span class="hs-special">)</span><span>
</span><a name="line-145"></a></pre></body></html>