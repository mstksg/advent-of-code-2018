-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Advent of Code 2018 solutions and auto-runner
--   
--   It's the Advent of Code 2018!
--   
--   This package contains Advent of 2018 solutions (spoilers!) and
--   auto-runner. Each challenge exists in its own module, and module
--   headers will also include a brief synopsis and reflection.
@package aoc2018
@version 0.1.0.0


-- | Utilities for loading configuration file.
module AOC.Run.Config

-- | Configuration for auto-runner.
data Config
Cfg :: Maybe String -> Integer -> Config

-- | Default: <a>Nothing</a>
[_cfgSession] :: Config -> Maybe String

-- | Default: 2015
[_cfgYear] :: Config -> Integer

-- | Load a <a>Config</a> from a given filepath.
configFile :: FilePath -> IO Config

-- | Default math to find a configuration file.
defConfPath :: FilePath

-- | Load a session token from the configuration file at a given filepath.
session :: FilePath -> IO (Maybe String)
instance GHC.Generics.Generic AOC.Run.Config.Config
instance Data.Default.Class.Default AOC.Run.Config.Config
instance Data.Aeson.Types.ToJSON.ToJSON AOC.Run.Config.Config
instance Data.Aeson.Types.FromJSON.FromJSON AOC.Run.Config.Config


-- | Assorted utility functions and orphans used for solutions.
module AOC.Util

-- | Strip trailing and leading whitespace.
strip :: String -> String

-- | Convert an <a>Either</a> into a <a>Maybe</a>, or any
--   <a>Alternative</a> instance, forgetting the error value.
eitherToMaybe :: Alternative m => Either e a -> m a

-- | Like <a>find</a>, but instead of taking an <tt>a -&gt; Bool</tt>,
--   takes an <tt>a -&gt; Maybe b</tt> and returns the first success.
findMaybe :: Foldable t => (a -> Maybe b) -> t a -> Maybe b

-- | Convert a <a>Maybe</a> into an <a>Either</a>, or any <a>MonadError</a>
--   instance, by providing an error value in case <a>Nothing</a> was
--   given.
maybeToEither :: MonadError e m => e -> Maybe a -> m a


-- | Common functions for solutions
module AOC.Common

-- | Iterate until a <a>Nothing</a> is produced
iterateMaybe :: (a -> Maybe a) -> a -> [a]

-- | Strict (!!)
(!!!) :: [a] -> Int -> a

-- | A tuple of the same item twice
dup :: a -> (a, a)

-- | <a>scanl</a> generalized to all <a>Traversable</a>.
scanlT :: Traversable t => (b -> a -> b) -> b -> t a -> t b

-- | <a>scanr</a> generalized to all <a>Traversable</a>.
scanrT :: Traversable t => (a -> b -> b) -> b -> t a -> t b

-- | Lazily find the first repeated item.
firstRepeated :: Ord a => [a] -> Maybe a

-- | Build a frequency map
freqs :: (Foldable f, Ord a) => f a -> Map a Int

-- | Collect all possible single-item perturbations from a given perturbing
--   function.
--   
--   <pre>
--   perturbations (\i -&gt; [i - 1, i + 1]) [0,10,100]
--   </pre>
--   
--   <h2>[ [-1,10,100]</h2>
--   
--   , [ 1,10,100] , [ 0, 9,100] , [ 0,11,100] , [ 0,10, 99] , [ 0,10,101]
--   ]
perturbations :: (a -> [a]) -> [a] -> [[a]]

-- | Clear out characters not matching a predicate
clearOut :: (Char -> Bool) -> String -> String

-- | Get the key-value pair corresponding to the maximum value in the map
maximumVal :: Ord b => Map a b -> Maybe (a, b)

-- | Get the key-value pair corresponding to the maximum value in the map,
--   with a custom comparing function.
--   
--   <pre>
--   'maximumVal' == 'maximumValBy' 'compare'
--   </pre>
maximumValBy :: (b -> b -> Ordering) -> Map a b -> Maybe (a, b)

-- | Get the key-value pair corresponding to the minimum value in the map
minimumVal :: Ord b => Map a b -> Maybe (a, b)

-- | Get the key-value pair corresponding to the minimum value in the map,
--   with a custom comparing function.
--   
--   <pre>
--   'minimumVal' == 'minimumValBy' 'compare'
--   </pre>
minimumValBy :: (b -> b -> Ordering) -> Map a b -> Maybe (a, b)

-- | Version of <a>maximumVal</a> for nonempty maps.
maximumValNE :: Ord b => NEMap a b -> (a, b)

-- | Version of <a>maximumValBy</a> for nonempty maps.
maximumValByNE :: (b -> b -> Ordering) -> NEMap a b -> (a, b)

-- | Version of <a>minimumVal</a> for nonempty maps.
minimumValNE :: Ord b => NEMap a b -> (a, b)

-- | Version of <a>minimumValBy</a> for nonempty maps.
minimumValByNE :: (b -> b -> Ordering) -> NEMap a b -> (a, b)

-- | Delete a potential value from a <a>Finite</a>.
deleteFinite :: KnownNat n => Finite (n + 1) -> Finite (n + 1) -> Maybe (Finite n)

-- | <a>foldMap</a>, but in parallel.
foldMapPar :: Monoid b => (a -> b) -> [a] -> b

-- | <tt>foldMap1</tt>, but in parallel.
foldMapPar1 :: Semigroup b => (a -> b) -> NonEmpty a -> b

-- | <a>Fold</a> for computing mean and variance
meanVar :: Fractional a => Fold a (a, a)

module AOC.Util.DynoMap
newtype DynoMap
Dyno :: Map String Dynamic -> DynoMap
[runDyno] :: DynoMap -> Map String Dynamic

-- | Lookup the value at a given key in a <a>Dyno</a>.
--   
--   <pre>
--   lookupDyno "hello"
--   </pre>
lookupDyno :: forall a. Typeable a => String -> DynoMap -> Maybe a

-- | Like <a>lookupDyno</a>, but with a default value to be returned if the
--   key is not found or has the wrong type.
lookupDynoWith :: forall a. Typeable a => String -> a -> DynoMap -> a
instance GHC.Base.Monoid AOC.Util.DynoMap.DynoMap
instance GHC.Base.Semigroup AOC.Util.DynoMap.DynoMap


-- | Types to drive the challenge runner and help speed up/clean up
--   solutions.
module AOC.Solver

-- | Abstracting over the type of a challenge solver to help with cleaner
--   solutions.
--   
--   A <tt>a <a>:~&gt;</a> b</tt> encapsulates something that solves a
--   challenge with input type <tt>a</tt> into a response of type
--   <tt>b</tt>.
--   
--   Consists of a parser, a shower, and a solver. The solver solves a
--   general <tt>a -&gt; <a>Maybe</a> b</tt> function, and the parser and
--   shower are used to handle the boilerplate of parsing and printing the
--   solution.
data a :~> b
MkSol :: (String -> Maybe a) -> (?dyno :: DynoMap => a -> Maybe b) -> (b -> String) -> (:~>) a b

-- | parse input into an <tt>a</tt>
[sParse] :: (:~>) a b -> String -> Maybe a

-- | solve an <tt>a</tt> input to a <tt>b</tt> solution
[sSolve] :: (:~>) a b -> ?dyno :: DynoMap => a -> Maybe b

-- | print out the <tt>b</tt> solution in a pretty way
[sShow] :: (:~>) a b -> b -> String

-- | Construct a <a>:~&gt;</a> from a <tt>String -&gt; <a>Maybe</a>
--   String</tt> solver, which might fail. Does no parsing or special
--   printing treatment.
withSolver :: (String -> Maybe String) -> String :~> String

-- | Construct a <a>:~&gt;</a> from just a normal <tt>String -&gt;
--   String</tt> solver. Does no parsing or special printing treatment.
withSolver' :: (String -> String) -> String :~> String

-- | Wrap an <tt>a <a>:~&gt;</a> b</tt> and hide the type variables so we
--   can put different solutions in a container.
data SomeSolution
[MkSomeSol] :: (a :~> b) -> SomeSolution

-- | Errors that might happen when running a <a>:~&gt;</a> on some input.
data SolutionError
SEParse :: SolutionError
SESolve :: SolutionError

-- | Run a <a>:~&gt;</a> on some input.
runSolution :: (a :~> b) -> String -> Either SolutionError String

-- | Run a <a>SomeSolution</a> on some input.
runSomeSolution :: SomeSolution -> String -> Either SolutionError String

-- | Run a <a>:~&gt;</a> on some input, with a map of dynamic values for
--   testing
runSolutionWith :: Map String Dynamic -> (a :~> b) -> String -> Either SolutionError String

-- | Run a <a>SomeSolution</a> on some input, with a map of dynamic values
--   for testing
runSomeSolutionWith :: Map String Dynamic -> SomeSolution -> String -> Either SolutionError String

-- | From a <tt>?dyno</tt> Implicit Params, look up a value at a given key.
--   Meant to be used with TypeApplications:
--   
--   <pre>
--   'dyno' @"hello"
--   </pre>
--   
--   This can be used within the body of <a>sSolve</a>, since it will
--   always be called with the implicit parameter.
--   
--   When called on actual puzzle input, result will always be
--   <a>Nothing</a>. But, for some test inputs, there might be supplied
--   values.
--   
--   This is useful for when some problems have parameters that are
--   different with test inputs than for actual inputs.
dyno :: forall a. (Typeable a, ?dyno :: DynoMap) => String -> Maybe a

-- | A version of <a>dyno</a> taking a default value in case the key is not
--   in the map. When called on actual puzzle input, this is always
--   <a>id</a>. However, for some test inputs, there might be supplied
--   values.
--   
--   Meant to be used with TypeApplications:
--   
--   <pre>
--   'dyno_' @"hello" 7
--   </pre>
--   
--   This is useful for when some problems have parameters that are
--   different with test inputs than for actual inputs.
dyno_ :: forall a. (Typeable a, ?dyno :: DynoMap) => String -> a -> a
instance GHC.Generics.Generic AOC.Solver.SolutionError
instance GHC.Classes.Ord AOC.Solver.SolutionError
instance GHC.Classes.Eq AOC.Solver.SolutionError
instance GHC.Show.Show AOC.Solver.SolutionError
instance Control.DeepSeq.NFData AOC.Solver.SolutionError


-- | Custom Prelude while developing challenges. Ideally, once challenges
--   are completed, an import to this module would be replaced with
--   explicit ones for future readers.
module AOC.Prelude

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: () => [a] -> [a] -> [a]
infixr 5 ++

-- | <a>filter</a>, applied to a predicate and a list, returns the list of
--   those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
filter :: () => (a -> Bool) -> [a] -> [a]

-- | <a>zip</a> takes two lists and returns a list of corresponding pairs.
--   
--   <pre>
--   zip [1, 2] ['a', 'b'] = [(1, 'a'), (2, 'b')]
--   </pre>
--   
--   If one input list is short, excess elements of the longer list are
--   discarded:
--   
--   <pre>
--   zip [1] ['a', 'b'] = [(1, 'a')]
--   zip [1, 2] ['a'] = [(1, 'a')]
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   zip [] _|_ = []
--   zip _|_ [] = _|_
--   </pre>
zip :: () => [a] -> [b] -> [(a, b)]

-- | Extract the first component of a pair.
fst :: () => (a, b) -> a

-- | Extract the second component of a pair.
snd :: () => (a, b) -> b

-- | The <a>trace</a> function outputs the trace message given as its first
--   argument, before returning the second argument as its result.
--   
--   For example, this returns the value of <tt>f x</tt> but first outputs
--   the message.
--   
--   <pre>
--   &gt;&gt;&gt; let x = 123; f = show
--   
--   &gt;&gt;&gt; trace ("calling f with x = " ++ show x) (f x)
--   "calling f with x = 123
--   123"
--   </pre>
--   
--   The <a>trace</a> function should <i>only</i> be used for debugging, or
--   for monitoring execution. The function is not referentially
--   transparent: its type indicates that it is a pure function but it has
--   the side effect of outputting the trace message.
trace :: () => String -> a -> a

-- | <a>map</a> <tt>f xs</tt> is the list obtained by applying <tt>f</tt>
--   to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
map :: () => (a -> b) -> [a] -> [b]

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>($)</tt> is levity-polymorphic in its result type, so
--   that foo $ True where foo :: Bool -&gt; Int# is well-typed
($) :: () => (a -> b) -> a -> b
infixr 0 $

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signaling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signaling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>join</a> is to run an <a>IO</a> computation
--   returned from an <a>STM</a> transaction, since <a>STM</a> transactions
--   can't perform <a>IO</a> directly. Recall that
--   
--   <pre>
--   <a>atomically</a> :: STM a -&gt; IO a
--   </pre>
--   
--   is used to run <a>STM</a> transactions atomically. So, by specializing
--   the types of <a>atomically</a> and <a>join</a> to
--   
--   <pre>
--   <a>atomically</a> :: STM (IO b) -&gt; IO (IO b)
--   <a>join</a>       :: IO (IO b)  -&gt; IO b
--   </pre>
--   
--   we can compose them as
--   
--   <pre>
--   <a>join</a> . <a>atomically</a> :: STM (IO b) -&gt; IO b
--   </pre>
--   
--   to run an <a>STM</a> transaction and the <a>IO</a> action it returns.
join :: Monad m => m (m a) -> m a

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>return</a> a <a>&gt;&gt;=</a> k = k a</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> <a>return</a> = m</pre></li>
--   <li><pre>m <a>&gt;&gt;=</a> (\x -&gt; k x <a>&gt;&gt;=</a> h) = (m
--   <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a> h</pre></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a

-- | Fail with a message. This operation is not part of the mathematical
--   definition of a monad, but is invoked on pattern-match failure in a
--   <tt>do</tt> expression.
--   
--   As part of the MonadFail proposal (MFP), this function is moved to its
--   own class <tt>MonadFail</tt> (see <a>Control.Monad.Fail</a> for more
--   details). The definition here will be removed in a future release.
fail :: Monad m => String -> m a
infixl 1 >>=
infixl 1 >>

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor (f :: Type -> Type)
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   The Haskell Report defines no laws for <a>Ord</a>. However,
--   <a>&lt;=</a> is customarily expected to implement a non-strict partial
--   order and have the following properties:
--   
--   <ul>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   Note that the following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 <=
infix 4 <
infix 4 >

-- | The <a>Ix</a> class is used to map a contiguous subrange of values in
--   a type onto integers. It is used primarily for array indexing (see the
--   array package).
--   
--   The first argument <tt>(l,u)</tt> of each of these operations is a
--   pair specifying the lower and upper bounds of a contiguous subrange of
--   values.
--   
--   An implementation is entitled to assume the following laws about these
--   operations:
--   
--   <ul>
--   <li><tt><a>inRange</a> (l,u) i == <a>elem</a> i (<a>range</a>
--   (l,u))</tt> <tt> </tt></li>
--   <li><tt><a>range</a> (l,u) <a>!!</a> <a>index</a> (l,u) i == i</tt>,
--   when <tt><a>inRange</a> (l,u) i</tt></li>
--   <li><tt><a>map</a> (<a>index</a> (l,u)) (<a>range</a> (l,u))) ==
--   [0..<a>rangeSize</a> (l,u)-1]</tt> <tt> </tt></li>
--   <li><tt><a>rangeSize</a> (l,u) == <a>length</a> (<a>range</a>
--   (l,u))</tt> <tt> </tt></li>
--   </ul>
class Ord a => Ix a

-- | The list of values in the subrange defined by a bounding pair.
range :: Ix a => (a, a) -> [a]

-- | The position of a subscript in the subrange.
index :: Ix a => (a, a) -> a -> Int

-- | Returns <a>True</a> the given subscript lies in the range defined the
--   bounding pair.
inRange :: Ix a => (a, a) -> a -> Bool

-- | The size of the subrange defined by a bounding pair.
rangeSize :: Ix a => (a, a) -> Int

-- | Monads having fixed points with a 'knot-tying' semantics. Instances of
--   <a>MonadFix</a> should satisfy the following laws:
--   
--   <ul>
--   <li><i><i>purity</i></i> <tt><a>mfix</a> (<tt>return</tt> . h) =
--   <tt>return</tt> (<a>fix</a> h)</tt></li>
--   <li><i><i>left shrinking</i> (or <i>tightening</i>)</i>
--   <tt><a>mfix</a> (\x -&gt; a &gt;&gt;= \y -&gt; f x y) = a &gt;&gt;= \y
--   -&gt; <a>mfix</a> (\x -&gt; f x y)</tt></li>
--   <li><i><i>sliding</i></i> <tt><a>mfix</a> (<a>liftM</a> h . f) =
--   <a>liftM</a> h (<a>mfix</a> (f . h))</tt>, for strict <tt>h</tt>.</li>
--   <li><i><i>nesting</i></i> <tt><a>mfix</a> (\x -&gt; <a>mfix</a> (\y
--   -&gt; f x y)) = <a>mfix</a> (\x -&gt; f x x)</tt></li>
--   </ul>
--   
--   This class is used in the translation of the recursive <tt>do</tt>
--   notation supported by GHC and Hugs.
class Monad m => MonadFix (m :: Type -> Type)

-- | The fixed point of a monadic computation. <tt><a>mfix</a> f</tt>
--   executes the action <tt>f</tt> only once, with the eventual output fed
--   back as the input. Hence <tt>f</tt> should not be strict, for then
--   <tt><a>mfix</a> f</tt> would diverge.
mfix :: MonadFix m => (a -> m a) -> m a

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <tt>&lt;$&gt;</tt> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i><i>identity</i></i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a>
--   v = v</pre></li>
--   <li><i><i>composition</i></i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i><i>homomorphism</i></i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i><i>interchange</i></i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | Data structures that can be folded.
--   
--   For example, given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Foldable Tree where
--      foldMap f Empty = mempty
--      foldMap f (Leaf x) = f x
--      foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--   </pre>
--   
--   This is suitable even for abstract types, as the monoid is assumed to
--   satisfy the monoid laws. Alternatively, one could define
--   <tt>foldr</tt>:
--   
--   <pre>
--   instance Foldable Tree where
--      foldr f z Empty = z
--      foldr f z (Leaf x) = f x z
--      foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
--   </pre>
--   
--   <tt>Foldable</tt> instances are expected to satisfy the following
--   laws:
--   
--   <pre>
--   foldr f z t = appEndo (foldMap (Endo . f) t ) z
--   </pre>
--   
--   <pre>
--   foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
--   </pre>
--   
--   <pre>
--   fold = foldMap id
--   </pre>
--   
--   <pre>
--   length = getSum . foldMap (Sum . const  1)
--   </pre>
--   
--   <tt>sum</tt>, <tt>product</tt>, <tt>maximum</tt>, and <tt>minimum</tt>
--   should all be essentially equivalent to <tt>foldMap</tt> forms, such
--   as
--   
--   <pre>
--   sum = getSum . foldMap Sum
--   </pre>
--   
--   but may be less defined.
--   
--   If the type is also a <a>Functor</a> instance, it should satisfy
--   
--   <pre>
--   foldMap f = fold . fmap f
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   foldMap f . fmap g = foldMap (f . g)
--   </pre>
class Foldable (t :: Type -> Type)

-- | Combine the elements of a structure using a monoid.
fold :: (Foldable t, Monoid m) => t m -> m

-- | Map each element of the structure to a monoid, and combine the
--   results.
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that, since the head of the resulting expression is produced by
--   an application of the operator to the first element of the list,
--   <a>foldr</a> can produce a terminating expression from an infinite
--   list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Right-associative fold of a structure, but with strict application of
--   the operator.
foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure.
--   
--   In the case of lists, <a>foldl</a>, when applied to a binary operator,
--   a starting value (typically the left-identity of the operator), and a
--   list, reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. This means that <a>foldl'</a>
--   will diverge if given an infinite list.
--   
--   Also note that if you want an efficient left-fold, you probably want
--   to use <a>foldl'</a> instead of <a>foldl</a>. The reason for this is
--   that latter does not force the "inner" results (e.g. <tt>z <tt>f</tt>
--   x1</tt> in the above example) before applying them to the operator
--   (e.g. to <tt>(<tt>f</tt> x2)</tt>). This results in a thunk chain
--   <tt>O(n)</tt> elements long, which then must be evaluated from the
--   outside-in.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl f z = <a>foldl</a> f z . <a>toList</a>
--   </pre>
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to weak head normal
--   form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite list to a single, monolithic result (e.g. <a>length</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | A variant of <a>foldr</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldr1</a> f = <a>foldr1</a> f . <a>toList</a>
--   </pre>
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | A variant of <a>foldl</a> that has no base case, and thus may only be
--   applied to non-empty structures.
--   
--   <pre>
--   <a>foldl1</a> f = <a>foldl1</a> f . <a>toList</a>
--   </pre>
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a

-- | List of elements of a structure, from left to right.
toList :: Foldable t => t a -> [a]

-- | Test whether the structure is empty. The default implementation is
--   optimized for structures that are similar to cons-lists, because there
--   is no general way to do better.
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation is optimized for structures that are similar to
--   cons-lists, because there is no general way to do better.
length :: Foldable t => t a -> Int

-- | Does the element occur in the structure?
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The largest element of a non-empty structure.
maximum :: (Foldable t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
minimum :: (Foldable t, Ord a) => t a -> a

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
product :: (Foldable t, Num a) => t a -> a
infix 4 `elem`

-- | Functors representing data structures that can be traversed from left
--   to right.
--   
--   A definition of <a>traverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt>t . <a>traverse</a> f =
--   <a>traverse</a> (t . f)</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>traverse</a> Identity =
--   Identity</tt></li>
--   <li><i><i>composition</i></i> <tt><a>traverse</a> (Compose .
--   <a>fmap</a> g . f) = Compose . <a>fmap</a> (<a>traverse</a> g) .
--   <a>traverse</a> f</tt></li>
--   </ul>
--   
--   A definition of <a>sequenceA</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt>t . <a>sequenceA</a> =
--   <a>sequenceA</a> . <a>fmap</a> t</tt> for every applicative
--   transformation <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>sequenceA</a> . <a>fmap</a> Identity
--   = Identity</tt></li>
--   <li><i><i>composition</i></i> <tt><a>sequenceA</a> . <a>fmap</a>
--   Compose = Compose . <a>fmap</a> <a>sequenceA</a> .
--   <a>sequenceA</a></tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations, i.e.
--   
--   <ul>
--   <li><pre>t (<a>pure</a> x) = <a>pure</a> x</pre></li>
--   <li><pre>t (x <a>&lt;*&gt;</a> y) = t x <a>&lt;*&gt;</a> t
--   y</pre></li>
--   </ul>
--   
--   and the identity functor <tt>Identity</tt> and composition of functors
--   <tt>Compose</tt> are defined as
--   
--   <pre>
--   newtype Identity a = Identity a
--   
--   instance Functor Identity where
--     fmap f (Identity x) = Identity (f x)
--   
--   instance Applicative Identity where
--     pure x = Identity x
--     Identity f &lt;*&gt; Identity x = Identity (f x)
--   
--   newtype Compose f g a = Compose (f (g a))
--   
--   instance (Functor f, Functor g) =&gt; Functor (Compose f g) where
--     fmap f (Compose x) = Compose (fmap (fmap f) x)
--   
--   instance (Applicative f, Applicative g) =&gt; Applicative (Compose f g) where
--     pure x = Compose (pure (pure x))
--     Compose f &lt;*&gt; Compose x = Compose ((&lt;*&gt;) &lt;$&gt; f &lt;*&gt; x)
--   </pre>
--   
--   (The naturality law is implied by parametricity.)
--   
--   Instances are similar to <a>Functor</a>, e.g. given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Traversable Tree where
--      traverse f Empty = pure Empty
--      traverse f (Leaf x) = Leaf &lt;$&gt; f x
--      traverse f (Node l k r) = Node &lt;$&gt; traverse f l &lt;*&gt; f k &lt;*&gt; traverse f r
--   </pre>
--   
--   This is suitable even for abstract types, as the laws for
--   <a>&lt;*&gt;</a> imply a form of associativity.
--   
--   The superclass instances should satisfy the following:
--   
--   <ul>
--   <li>In the <a>Functor</a> instance, <a>fmap</a> should be equivalent
--   to traversal with the identity applicative functor
--   (<a>fmapDefault</a>).</li>
--   <li>In the <a>Foldable</a> instance, <a>foldMap</a> should be
--   equivalent to traversal with a constant applicative functor
--   (<a>foldMapDefault</a>).</li>
--   </ul>
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <tt>id</tt>
--   <a>to</a> . <a>from</a> ≡ <tt>id</tt>
--   </pre>
class Generic a

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the associativity law:
--   
--   <ul>
--   <li><pre>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) = (x <a>&lt;&gt;</a>
--   y) <a>&lt;&gt;</a> z</pre></li>
--   </ul>
class Semigroup a

-- | An associative operation.
(<>) :: Semigroup a => a -> a -> a

-- | Reduce a non-empty list with <tt>&lt;&gt;</tt>
--   
--   The default definition should be sufficient, but this can be
--   overridden for efficiency.
sconcat :: Semigroup a => NonEmpty a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   Given that this works on a <a>Semigroup</a> it is allowed to fail if
--   you request 0 or fewer repetitions, and the default definition will do
--   so.
--   
--   By making this a member of the class, idempotent semigroups and
--   monoids can upgrade this to execute in <i>O(1)</i> by picking
--   <tt>stimes = <tt>stimesIdempotent</tt></tt> or <tt>stimes =
--   <a>stimesIdempotentMonoid</a></tt> respectively.
stimes :: (Semigroup a, Integral b) => b -> a -> a
infixr 6 <>

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char

-- | Type representing arbitrary-precision non-negative integers.
--   
--   <pre>
--   &gt;&gt;&gt; 2^100 :: Natural
--   1267650600228229401496703205376
--   </pre>
--   
--   Operations whose result would be negative <tt><tt>throw</tt>
--   (<tt>Underflow</tt> :: <tt>ArithException</tt>)</tt>,
--   
--   <pre>
--   &gt;&gt;&gt; -1 :: Natural
--   *** Exception: arithmetic underflow
--   </pre>
data Natural

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <tt>error</tt>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | <tt>RealWorld</tt> is deeply magical. It is <i>primitive</i>, but it
--   is not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <tt>RealWorld</tt>; it's only used in the type system,
--   to parameterise <tt>State#</tt>.
data RealWorld :: Type

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | The kind of types with values. For example <tt>Int :: Type</tt>.
type Type = Type

-- | The kind of constraints, like <tt>Show a</tt>
data Constraint

-- | Use <tt><a>Option</a> (<a>Last</a> a)</tt> to get the behavior of
--   <a>Last</a> from <a>Data.Monoid</a>
newtype Last a
Last :: a -> Last a
[getLast] :: Last a -> a

-- | A class of types that can be fully evaluated.
class NFData a

-- | <a>rnf</a> should reduce its argument to normal form (that is, fully
--   evaluate all sub-components), and then return '()'.
--   
--   <h3><a>Generic</a> <a>NFData</a> deriving</h3>
--   
--   Starting with GHC 7.2, you can automatically derive instances for
--   types possessing a <a>Generic</a> instance.
--   
--   Note: <a>Generic1</a> can be auto-derived starting with GHC 7.4
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics (Generic, Generic1)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, Generic1)
--   
--   instance NFData a =&gt; NFData (Foo a)
--   instance NFData1 Foo
--   
--   data Colour = Red | Green | Blue
--                 deriving Generic
--   
--   instance NFData Colour
--   </pre>
--   
--   Starting with GHC 7.10, the example above can be written more
--   concisely by enabling the new <tt>DeriveAnyClass</tt> extension:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric, DeriveAnyClass #-}
--   
--   import GHC.Generics (Generic)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, Generic1, NFData, NFData1)
--   
--   data Colour = Red | Green | Blue
--                 deriving (Generic, NFData)
--   </pre>
--   
--   <h3>Compatibility with previous <tt>deepseq</tt> versions</h3>
--   
--   Prior to version 1.4.0.0, the default implementation of the <a>rnf</a>
--   method was defined as
--   
--   <pre>
--   <a>rnf</a> a = <a>seq</a> a ()
--   </pre>
--   
--   However, starting with <tt>deepseq-1.4.0.0</tt>, the default
--   implementation is based on <tt>DefaultSignatures</tt> allowing for
--   more accurate auto-derived <a>NFData</a> instances. If you need the
--   previously used exact default <a>rnf</a> method implementation
--   semantics, use
--   
--   <pre>
--   instance NFData Colour where rnf x = seq x ()
--   </pre>
--   
--   or alternatively
--   
--   <pre>
--   instance NFData Colour where rnf = rwhnf
--   </pre>
--   
--   or
--   
--   <pre>
--   {-# LANGUAGE BangPatterns #-}
--   instance NFData Colour where rnf !_ = ()
--   </pre>
rnf :: NFData a => a -> ()

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
data Map k a

-- | Monads that also support choice and failure.
class (Alternative m, Monad m) => MonadPlus (m :: Type -> Type)

-- | The identity of <a>mplus</a>. It should also satisfy the equations
--   
--   <pre>
--   mzero &gt;&gt;= f  =  mzero
--   v &gt;&gt; mzero   =  mzero
--   </pre>
--   
--   The default definition is
--   
--   <pre>
--   mzero = <a>empty</a>
--   </pre>
mzero :: MonadPlus m => m a

-- | An associative operation. The default definition is
--   
--   <pre>
--   mplus = (<a>&lt;|&gt;</a>)
--   </pre>
mplus :: MonadPlus m => m a -> m a -> m a

-- | A monoid on applicative functors.
--   
--   If defined, <a>some</a> and <a>many</a> should be the least solutions
--   of the equations:
--   
--   <ul>
--   <li><pre><a>some</a> v = (:) <tt>&lt;$&gt;</tt> v <a>&lt;*&gt;</a>
--   <a>many</a> v</pre></li>
--   <li><pre><a>many</a> v = <a>some</a> v <a>&lt;|&gt;</a> <a>pure</a>
--   []</pre></li>
--   </ul>
class Applicative f => Alternative (f :: Type -> Type)

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => f a

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
many :: Alternative f => f a -> f [a]
infixl 3 <|>

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | Promote a function to a monad.
liftM :: Monad m => (a1 -> r) -> m a1 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right. For example,
--   
--   <pre>
--   liftM2 (+) [0,1] [0,2] = [0,2,1,3]
--   liftM2 (+) (Just 1) Nothing = Nothing
--   </pre>
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | In many situations, the <a>liftM</a> operations can be replaced by
--   uses of <a>ap</a>, which promotes function application.
--   
--   <pre>
--   return f `ap` x1 `ap` ... `ap` xn
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   liftMn f x1 x2 ... xn
--   </pre>
ap :: Monad m => m (a -> b) -> m a -> m b

-- | The <a>fromEnum</a> method restricted to the type <a>Char</a>.
ord :: Char -> Int

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: () => a -> a

-- | <tt>const x</tt> is a unary function which evaluates to <tt>x</tt> for
--   all inputs.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: () => a -> b -> a

-- | Function composition.
(.) :: () => (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: () => (a -> b -> c) -> b -> a -> c

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: () => ((a, b) -> c) -> a -> b -> c

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: () => (a -> b -> c) -> (a, b) -> c

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <tt>show</tt> to a <tt>Maybe Int</tt>. If we have <tt>Just
--   n</tt>, we want to show the underlying <a>Int</a> <tt>n</tt>. But if
--   we have <a>Nothing</a>, we return the empty string instead of (for
--   example) "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: () => b -> (a -> b) -> Maybe a -> b

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: () => Maybe a -> Bool

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just 3)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just ())
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just Nothing)
--   False
--   </pre>
isNothing :: () => Maybe a -> Bool

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <tt>readMaybe</tt>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: () => a -> Maybe a -> a

-- | The <a>maybeToList</a> function returns an empty list when given
--   <a>Nothing</a> or a singleton list when not given <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList (Just 7)
--   [7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList Nothing
--   []
--   </pre>
--   
--   One can use <a>maybeToList</a> to avoid pattern matching when combined
--   with a function that (safely) works on lists:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "3")
--   3
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "")
--   0
--   </pre>
maybeToList :: () => Maybe a -> [a]

-- | The <a>listToMaybe</a> function returns <a>Nothing</a> on an empty
--   list or <tt><a>Just</a> a</tt> where <tt>a</tt> is the first element
--   of the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [9]
--   Just 9
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [1,2,3]
--   Just 1
--   </pre>
--   
--   Composing <a>maybeToList</a> with <a>listToMaybe</a> should be the
--   identity on singleton/empty lists:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [5]
--   [5]
--   
--   &gt;&gt;&gt; maybeToList $ listToMaybe []
--   []
--   </pre>
--   
--   But not on lists with more than one element:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [1,2,3]
--   [1]
--   </pre>
listToMaybe :: () => [a] -> Maybe a

-- | Extract the first element of a list, which must be non-empty.
head :: () => [a] -> a

-- | Extract the elements after the head of a list, which must be
--   non-empty.
tail :: () => [a] -> [a]

-- | Extract the last element of a list, which must be finite and
--   non-empty.
last :: () => [a] -> a

-- | Return all the elements of a list except the last one. The list must
--   be non-empty.
init :: () => [a] -> [a]

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a list of
--   successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: () => (b -> a -> b) -> b -> [a] -> [b]

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: () => (a -> a -> a) -> [a] -> [a]

-- | <a>scanr</a> is the right-to-left dual of <a>scanl</a>. Note that
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs.
--   </pre>
scanr :: () => (a -> b -> b) -> b -> [a] -> [b]

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: () => (a -> a -> a) -> [a] -> [a]

-- | <a>iterate</a> <tt>f x</tt> returns an infinite list of repeated
--   applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
--   
--   Note that <a>iterate</a> is lazy, potentially leading to thunk
--   build-up if the consumer doesn't force each iterate. See 'iterate\''
--   for a strict variant of this function.
iterate :: () => (a -> a) -> a -> [a]

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
repeat :: () => a -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
replicate :: () => Int -> a -> [a]

-- | <a>cycle</a> ties a finite list into a circular one, or equivalently,
--   the infinite repetition of the original list. It is the identity on
--   infinite lists.
cycle :: () => [a] -> [a]

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>:
--   
--   <pre>
--   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
--   takeWhile (&lt; 9) [1,2,3] == [1,2,3]
--   takeWhile (&lt; 0) [1,2,3] == []
--   </pre>
takeWhile :: () => (a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: () => (a -> Bool) -> [a] -> [a]

-- | <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>, returns the
--   prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt> itself if
--   <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   It is an instance of the more general <a>genericTake</a>, in which
--   <tt>n</tt> may be of any integral type.
take :: () => Int -> [a] -> [a]

-- | <a>drop</a> <tt>n xs</tt> returns the suffix of <tt>xs</tt> after the
--   first <tt>n</tt> elements, or <tt>[]</tt> if <tt>n &gt; <a>length</a>
--   xs</tt>:
--   
--   <pre>
--   drop 6 "Hello World!" == "World!"
--   drop 3 [1,2,3,4,5] == [4,5]
--   drop 3 [1,2] == []
--   drop 3 [] == []
--   drop (-1) [1,2] == [1,2]
--   drop 0 [1,2] == [1,2]
--   </pre>
--   
--   It is an instance of the more general <a>genericDrop</a>, in which
--   <tt>n</tt> may be of any integral type.
drop :: () => Int -> [a] -> [a]

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   splitAt 6 "Hello World!" == ("Hello ","World!")
--   splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
--   splitAt 1 [1,2,3] == ([1],[2,3])
--   splitAt 3 [1,2,3] == ([1,2,3],[])
--   splitAt 4 [1,2,3] == ([1,2,3],[])
--   splitAt 0 [1,2,3] == ([],[1,2,3])
--   splitAt (-1) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt> when
--   <tt>n</tt> is not <tt>_|_</tt> (<tt>splitAt _|_ xs = _|_</tt>).
--   <a>splitAt</a> is an instance of the more general
--   <a>genericSplitAt</a>, in which <tt>n</tt> may be of any integral
--   type.
splitAt :: () => Int -> [a] -> ([a], [a])

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   span (&lt; 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])
--   span (&lt; 9) [1,2,3] == ([1,2,3],[])
--   span (&lt; 0) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: () => (a -> Bool) -> [a] -> ([a], [a])

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
--   break (&lt; 9) [1,2,3] == ([],[1,2,3])
--   break (&gt; 9) [1,2,3] == ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: () => (a -> Bool) -> [a] -> ([a], [a])

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
reverse :: () => [a] -> [a]

-- | <a>lookup</a> <tt>key assocs</tt> looks up a key in an association
--   list.
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
(!!) :: () => [a] -> Int -> a
infixl 9 !!

-- | <a>zip3</a> takes three lists and returns a list of triples, analogous
--   to <a>zip</a>.
zip3 :: () => [a] -> [b] -> [c] -> [(a, b, c)]

-- | <a>zipWith</a> generalises <a>zip</a> by zipping with the function
--   given as the first argument, instead of a tupling function. For
--   example, <tt><a>zipWith</a> (+)</tt> is applied to two lists to
--   produce the list of corresponding sums.
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   zipWith f [] _|_ = []
--   </pre>
zipWith :: () => (a -> b -> c) -> [a] -> [b] -> [c]

-- | The <a>zipWith3</a> function takes a function which combines three
--   elements, as well as three lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith3 :: () => (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

-- | <a>unzip</a> transforms a list of pairs into a list of first
--   components and a list of second components.
unzip :: () => [(a, b)] -> ([a], [b])

-- | The <a>unzip3</a> function takes a list of triples and returns three
--   lists, analogous to <a>unzip</a>.
unzip3 :: () => [(a, b, c)] -> ([a], [b], [c])

-- | The <a>toEnum</a> method restricted to the type <a>Char</a>.
chr :: Int -> Char

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <tt>$</tt>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <tt>$</tt> is function application, <a>&lt;$&gt;</a> is
--   function application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><tt>Maybe</tt> <tt>Int</tt></tt> to a
--   <tt><tt>Maybe</tt> <tt>String</tt></tt> using <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><tt>Either</tt> <tt>Int</tt> <tt>Int</tt></tt> to
--   an <tt><tt>Either</tt> <tt>Int</tt></tt> <tt>String</tt> using
--   <tt>show</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <tt>even</tt> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with
--   unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with unit, resulting in an <tt><tt>Either</tt>
--   <tt>Int</tt> '()'</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | Returns <a>True</a> for any Unicode space character, and the control
--   characters <tt>\t</tt>, <tt>\n</tt>, <tt>\r</tt>, <tt>\f</tt>,
--   <tt>\v</tt>.
isSpace :: Char -> Bool

-- | Selects ASCII digits, i.e. <tt>'0'</tt>..<tt>'9'</tt>.
isDigit :: Char -> Bool

-- | Selects alphabetic Unicode characters (lower-case, upper-case and
--   title-case letters, plus letters of caseless scripts and modifiers
--   letters). This function is equivalent to <a>isLetter</a>.
isAlpha :: Char -> Bool

-- | Selects alphabetic or numeric Unicode characters.
--   
--   Note that numeric digits outside the ASCII range, as well as numeric
--   characters which aren't digits, are selected by this function but not
--   by <a>isDigit</a>. Such characters may be part of identifiers but are
--   not used by the printer and reader to represent numbers.
isAlphaNum :: Char -> Bool

-- | Selects upper-case or title-case alphabetic Unicode characters
--   (letters). Title case is used by a small number of letter ligatures
--   like the single-character form of <i>Lj</i>.
isUpper :: Char -> Bool

-- | Convert a letter to the corresponding lower-case letter, if any. Any
--   other character is returned unchanged.
toLower :: Char -> Char

-- | Convert a letter to the corresponding upper-case letter, if any. Any
--   other character is returned unchanged.
toUpper :: Char -> Char

-- | <pre>
--   comparing p x y = compare (p x) (p y)
--   </pre>
--   
--   Useful combinator for use in conjunction with the <tt>xxxBy</tt>
--   family of functions from <a>Data.List</a>, for example:
--   
--   <pre>
--   ... sortBy (comparing fst) ...
--   </pre>
comparing :: Ord a => (b -> a) -> b -> b -> Ordering

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <tt>length</tt> function (if we have a <a>String</a>) or the
--   "times-two" function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: () => (a -> c) -> (b -> c) -> Either a b -> c

-- | The <a>isPrefixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a prefix of the second.
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Hello World!"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello" `isPrefixOf` "Wello Horld!"
--   False
--   </pre>
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isSuffixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is a suffix of the second. The second list must be
--   finite.
--   
--   <pre>
--   &gt;&gt;&gt; "ld!" `isSuffixOf` "Hello World!"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "World" `isSuffixOf` "Hello World!"
--   False
--   </pre>
isSuffixOf :: Eq a => [a] -> [a] -> Bool

-- | The <a>isInfixOf</a> function takes two lists and returns <a>True</a>
--   iff the first list is contained, wholly and intact, anywhere within
--   the second.
--   
--   <pre>
--   &gt;&gt;&gt; isInfixOf "Haskell" "I really like Haskell."
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isInfixOf "Ial" "I really like Haskell."
--   False
--   </pre>
isInfixOf :: Eq a => [a] -> [a] -> Bool

-- | <i>O(n^2)</i>. The <a>nub</a> function removes duplicate elements from
--   a list. In particular, it keeps only the first occurrence of each
--   element. (The name <a>nub</a> means `essence'.) It is a special case
--   of <a>nubBy</a>, which allows the programmer to supply their own
--   equality test.
--   
--   <pre>
--   &gt;&gt;&gt; nub [1,2,3,4,3,2,1,2,4,3,5]
--   [1,2,3,4,5]
--   </pre>
nub :: Eq a => [a] -> [a]

-- | The <a>nubBy</a> function behaves just like <a>nub</a>, except it uses
--   a user-supplied equality predicate instead of the overloaded <a>==</a>
--   function.
--   
--   <pre>
--   &gt;&gt;&gt; nubBy (\x y -&gt; mod x 3 == mod y 3) [1,2,4,5,6]
--   [1,2,6]
--   </pre>
nubBy :: () => (a -> a -> Bool) -> [a] -> [a]

-- | The <a>intersperse</a> function takes an element and a list and
--   `intersperses' that element between the elements of the list. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; intersperse ',' "abcde"
--   "a,b,c,d,e"
--   </pre>
intersperse :: () => a -> [a] -> [a]

-- | <a>intercalate</a> <tt>xs xss</tt> is equivalent to <tt>(<a>concat</a>
--   (<a>intersperse</a> xs xss))</tt>. It inserts the list <tt>xs</tt> in
--   between the lists in <tt>xss</tt> and concatenates the result.
--   
--   <pre>
--   &gt;&gt;&gt; intercalate ", " ["Lorem", "ipsum", "dolor"]
--   "Lorem, ipsum, dolor"
--   </pre>
intercalate :: () => [a] -> [[a]] -> [a]

-- | The <a>sort</a> function implements a stable sorting algorithm. It is
--   a special case of <a>sortBy</a>, which allows the programmer to supply
--   their own comparison function.
--   
--   Elements are arranged from from lowest to highest, keeping duplicates
--   in the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sort [1,6,4,3,2,5]
--   [1,2,3,4,5,6]
--   </pre>
sort :: Ord a => [a] -> [a]

-- | The <a>sortBy</a> function is the non-overloaded version of
--   <a>sort</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sortBy (\(a,_) (b,_) -&gt; compare a b) [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
sortBy :: () => (a -> a -> Ordering) -> [a] -> [a]

-- | The <a>unfoldr</a> function is a `dual' to <a>foldr</a>: while
--   <a>foldr</a> reduces a list to a summary value, <a>unfoldr</a> builds
--   a list from a seed value. The function takes the element and returns
--   <a>Nothing</a> if it is done producing the list or returns <a>Just</a>
--   <tt>(a,b)</tt>, in which case, <tt>a</tt> is a prepended to the list
--   and <tt>b</tt> is used as the next element in a recursive call. For
--   example,
--   
--   <pre>
--   iterate f == unfoldr (\x -&gt; Just (x, f x))
--   </pre>
--   
--   In some cases, <a>unfoldr</a> can undo a <a>foldr</a> operation:
--   
--   <pre>
--   unfoldr f' (foldr f z xs) == xs
--   </pre>
--   
--   if the following holds:
--   
--   <pre>
--   f' (f x y) = Just (x,y)
--   f' z       = Nothing
--   </pre>
--   
--   A simple use of unfoldr:
--   
--   <pre>
--   &gt;&gt;&gt; unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10
--   [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfoldr :: () => (b -> Maybe (a, b)) -> b -> [a]

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
--   
--   Note that after splitting the string at newline characters, the last
--   part of the string is considered a line even if it doesn't end with a
--   newline. For example,
--   
--   <pre>
--   &gt;&gt;&gt; lines ""
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n"
--   ["one","two"]
--   </pre>
--   
--   Thus <tt><a>lines</a> s</tt> contains at least as many elements as
--   newlines in <tt>s</tt>.
lines :: String -> [String]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
unlines :: [String] -> String

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
words :: String -> [String]

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
unwords :: [String] -> String

-- | Boolean monoid under disjunction (<a>||</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAny (Any True &lt;&gt; mempty &lt;&gt; Any False)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAny (mconcat (map (\x -&gt; Any (even x)) [2,4,6,7,8]))
--   True
--   </pre>
newtype Any
Any :: Bool -> Any
[getAny] :: Any -> Bool

-- | Boolean monoid under conjunction (<a>&amp;&amp;</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAll (All True &lt;&gt; mempty &lt;&gt; All False)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAll (mconcat (map (\x -&gt; All (even x)) [2,4,6,7,8]))
--   False
--   </pre>
newtype All
All :: Bool -> All
[getAll] :: All -> Bool

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and ignore the results. For a version that doesn't
--   ignore the results see <a>traverse</a>.
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()

-- | <a>for_</a> is <a>traverse_</a> with its arguments flipped. For a
--   version that doesn't ignore the results see <a>for</a>.
--   
--   <pre>
--   &gt;&gt;&gt; for_ [1..4] print
--   1
--   2
--   3
--   4
--   </pre>
for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   As of base 4.8.0.0, <a>sequence_</a> is just <a>sequenceA_</a>,
--   specialized to <a>Monad</a>.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | The concatenation of all the elements of a container of lists.
concat :: Foldable t => t [a] -> [a]

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
and :: Foldable t => t Bool -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
or :: Foldable t => t Bool -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether all elements of the structure satisfy the
--   predicate.
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | <a>notElem</a> is the negation of <a>elem</a>.
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | The <a>find</a> function takes a predicate and a structure and returns
--   the leftmost element of the structure matching the predicate, or
--   <a>Nothing</a> if there is no such element.
find :: Foldable t => (a -> Bool) -> t a -> Maybe a

-- | One or none.
optional :: Alternative f => f a -> f (Maybe a)

-- | <a>for</a> is <a>traverse</a> with its arguments flipped. For a
--   version that ignores the results see <a>for_</a>.
for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)

-- | This generalizes the list-based <tt>filter</tt> function.
filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]

-- | The <a>foldM</a> function is analogous to <tt>foldl</tt>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   
--   ==
--   
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
--   
--   Note: <a>foldM</a> is the same as <a>foldlM</a>
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | Lifts an <tt><a>Either</a> e</tt> into any <tt><a>MonadError</a>
--   e</tt>.
--   
--   <pre>
--   do { val &lt;- liftEither =&lt;&lt; action1; action2 }
--   </pre>
--   
--   where <tt>action1</tt> returns an <a>Either</a> to represent errors.
liftEither :: MonadError e m => Either e a -> m a

-- | A set of values <tt>a</tt>.
data Set a

-- | A variant of <a>&lt;*&gt;</a> with the arguments reversed.
(<**>) :: Applicative f => f a -> f (a -> b) -> f b
infixl 4 <**>

-- | Lift a function to actions. This function may be used as a value for
--   <a>fmap</a> in a <a>Functor</a> instance.
liftA :: Applicative f => (a -> b) -> f a -> f b

-- | Lift a ternary function to actions.
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM4 :: Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right (cf. <a>liftM2</a>).
liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r

-- | <tt><a>fix</a> f</tt> is the least fixed point of the function
--   <tt>f</tt>, i.e. the least defined <tt>x</tt> such that <tt>f x =
--   x</tt>.
--   
--   For example, we can write the factorial function using direct
--   recursion as
--   
--   <pre>
--   &gt;&gt;&gt; let fac n = if n &lt;= 1 then 1 else n * fac (n-1) in fac 5
--   120
--   </pre>
--   
--   This uses the fact that Haskell’s <tt>let</tt> introduces recursive
--   bindings. We can rewrite this definition using <a>fix</a>,
--   
--   <pre>
--   &gt;&gt;&gt; fix (\rec n -&gt; if n &lt;= 1 then 1 else n * rec (n-1)) 5
--   120
--   </pre>
--   
--   Instead of making a recursive call, we introduce a dummy parameter
--   <tt>rec</tt>; when used within <a>fix</a>, this parameter then refers
--   to <tt>fix'</tt> argument, hence the recursion is reintroduced.
fix :: () => (a -> a) -> a

-- | Parse a string using the <a>Read</a> instance. Succeeds if there is
--   exactly one valid result.
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "123" :: Maybe Int
--   Just 123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "hello" :: Maybe Int
--   Nothing
--   </pre>
readMaybe :: Read a => String -> Maybe a

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   As of base 4.8.0.0, <a>mapM_</a> is just <a>traverse_</a>, specialized
--   to <a>Monad</a>.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   As of base 4.8.0.0, <a>forM_</a> is just <a>for_</a>, specialized to
--   <a>Monad</a>.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | The sum of a collection of actions, generalizing <a>concat</a>. As of
--   base 4.8.0.0, <a>msum</a> is just <a>asum</a>, specialized to
--   <a>MonadPlus</a>.
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a

-- | The <a>Const</a> functor.
newtype Const a (b :: k) :: forall k. () => Type -> k -> Type
Const :: a -> Const a
[getConst] :: Const a -> a

-- | Lists, but with an <a>Applicative</a> functor based on zipping.
newtype ZipList a
ZipList :: [a] -> ZipList a
[getZipList] :: ZipList a -> [a]
newtype WrappedArrow (a :: Type -> Type -> Type) b c
WrapArrow :: a b c -> WrappedArrow b c
[unwrapArrow] :: WrappedArrow b c -> a b c
newtype WrappedMonad (m :: Type -> Type) a
WrapMonad :: m a -> WrappedMonad a
[unwrapMonad] :: WrappedMonad a -> m a

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)

-- | Left-to-right composition of Kleisli arrows.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | Right-to-left composition of Kleisli arrows.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | Repeat an action indefinitely.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>forever</a> is to process input from network
--   sockets, <a>Handle</a>s, and channels (e.g. <a>MVar</a> and
--   <a>Chan</a>).
--   
--   For example, here is how we might implement an <a>echo server</a>,
--   using <a>forever</a> both to listen for client connections on a
--   network socket and to echo client input on client connection handles:
--   
--   <pre>
--   echoServer :: Socket -&gt; IO ()
--   echoServer socket = <a>forever</a> $ do
--     client &lt;- accept socket
--     <a>forkFinally</a> (echo client) (\_ -&gt; hClose client)
--     where
--       echo :: Handle -&gt; IO ()
--       echo client = <a>forever</a> $
--         hGetLine client &gt;&gt;= hPutStrLn client
--   </pre>
forever :: Applicative f => f a -> f b

-- | The <a>mapAndUnzipM</a> function maps its first argument over a list,
--   returning the result as a pair of lists. This function is mainly used
--   with complicated data structures or a state-transforming monad.
mapAndUnzipM :: Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])

-- | The <a>zipWithM</a> function generalizes <a>zipWith</a> to arbitrary
--   applicative functors.
zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | <a>zipWithM_</a> is the extension of <a>zipWithM</a> which ignores the
--   final result.
zipWithM_ :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | Like <a>foldM</a>, but discards the result.
foldM_ :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()

-- | <tt><a>replicateM</a> n act</tt> performs the action <tt>n</tt> times,
--   gathering the results.
replicateM :: Applicative m => Int -> m a -> m [a]

-- | Like <a>replicateM</a>, but discards the result.
replicateM_ :: Applicative m => Int -> m a -> m ()

-- | Strict version of <a>&lt;$&gt;</a>.
(<$!>) :: Monad m => (a -> b) -> m a -> m b
infixl 4 <$!>

-- | Direct <a>MonadPlus</a> equivalent of <a>filter</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   The <a>filter</a> function is just <a>mfilter</a> specialized to the
--   list monad:
--   
--   <pre>
--   <a>filter</a> = ( <a>mfilter</a> :: (a -&gt; Bool) -&gt; [a] -&gt; [a] )
--   </pre>
--   
--   An example using <a>mfilter</a> with the <a>Maybe</a> monad:
--   
--   <pre>
--   &gt;&gt;&gt; mfilter odd (Just 1)
--   Just 1
--   &gt;&gt;&gt; mfilter odd (Just 2)
--   Nothing
--   </pre>
mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a

-- | Minimal definition is either both of <tt>get</tt> and <tt>put</tt> or
--   just <tt>state</tt>
class Monad m => MonadState s (m :: Type -> Type) | m -> s

-- | Return the state from the internals of the monad.
get :: MonadState s m => m s

-- | Replace the state inside the monad.
put :: MonadState s m => s -> m ()

-- | Embed a simple state action into the monad.
state :: MonadState s m => (s -> (a, s)) -> m a

-- | Finite number type. <tt><a>Finite</a> n</tt> is inhabited by exactly
--   <tt>n</tt> values. Invariants:
--   
--   <pre>
--   getFinite x &lt; natVal x
--   </pre>
--   
--   <pre>
--   getFinite x &gt;= 0
--   </pre>
data Finite (n :: Nat)

-- | This is the simplest representation of UTC. It consists of the day
--   number, and a time offset from midnight. Note that if a day has a leap
--   second added to it, it will have 86401 seconds.
data UTCTime
UTCTime :: Day -> DiffTime -> UTCTime

-- | the day
[utctDay] :: UTCTime -> Day

-- | the time from midnight, 0 &lt;= t &lt; 86401s (because of
--   leap-seconds)
[utctDayTime] :: UTCTime -> DiffTime

-- | If <a>Void</a> is uninhabited then any <a>Functor</a> that holds only
--   values of type <a>Void</a> is holding no values.
vacuous :: Functor f => f Void -> f a

-- | Since <a>Void</a> values logically don't exist, this witnesses the
--   logical reasoning tool of "ex falso quodlibet".
--   
--   <pre>
--   &gt;&gt;&gt; let x :: Either Void Int; x = Right 5
--   
--   &gt;&gt;&gt; :{
--   case x of
--       Right r -&gt; r
--       Left l  -&gt; absurd l
--   :}
--   5
--   </pre>
absurd :: () => Void -> a

-- | Uninhabited data type
data Void

-- | Fold an <a>Option</a> case-wise, just like <a>maybe</a>.
option :: () => b -> (a -> b) -> Option a -> b

-- | Repeat a value <tt>n</tt> times.
--   
--   <pre>
--   mtimesDefault n a = a &lt;&gt; a &lt;&gt; ... &lt;&gt; a  -- using &lt;&gt; (n-1) times
--   </pre>
--   
--   Implemented using <a>stimes</a> and <a>mempty</a>.
--   
--   This is a suitable definition for an <tt>mtimes</tt> member of
--   <a>Monoid</a>.
mtimesDefault :: (Integral b, Monoid a) => b -> a -> a

-- | This lets you use a difference list of a <a>Semigroup</a> as a
--   <a>Monoid</a>.
diff :: Semigroup m => m -> Endo m

-- | A generalization of <a>cycle</a> to an arbitrary <a>Semigroup</a>. May
--   fail to terminate for some values in some semigroups.
cycle1 :: Semigroup m => m -> m
newtype Min a
Min :: a -> Min a
[getMin] :: Min a -> a
newtype Max a
Max :: a -> Max a
[getMax] :: Max a -> a

-- | <a>Arg</a> isn't itself a <a>Semigroup</a> in its own right, but it
--   can be placed inside <a>Min</a> and <a>Max</a> to compute an arg min
--   or arg max.
data Arg a b
Arg :: a -> b -> Arg a b
type ArgMin a b = Min Arg a b
type ArgMax a b = Max Arg a b

-- | Use <tt><a>Option</a> (<a>First</a> a)</tt> to get the behavior of
--   <a>First</a> from <a>Data.Monoid</a>.
newtype First a
First :: a -> First a
[getFirst] :: First a -> a

-- | Provide a Semigroup for an arbitrary Monoid.
--   
--   <b>NOTE</b>: This is not needed anymore since <a>Semigroup</a> became
--   a superclass of <a>Monoid</a> in <i>base-4.11</i> and this newtype be
--   deprecated at some point in the future.
newtype WrappedMonoid m
WrapMonoid :: m -> WrappedMonoid m
[unwrapMonoid] :: WrappedMonoid m -> m

-- | <a>Option</a> is effectively <a>Maybe</a> with a better instance of
--   <a>Monoid</a>, built off of an underlying <a>Semigroup</a> instead of
--   an underlying <a>Monoid</a>.
--   
--   Ideally, this type would not exist at all and we would just fix the
--   <a>Monoid</a> instance of <a>Maybe</a>.
--   
--   In GHC 8.4 and higher, the <a>Monoid</a> instance for <a>Maybe</a> has
--   been corrected to lift a <a>Semigroup</a> instance instead of a
--   <a>Monoid</a> instance. Consequently, this type is no longer useful.
--   It will be marked deprecated in GHC 8.8 and removed in GHC 8.10.
newtype Option a
Option :: Maybe a -> Option a
[getOption] :: Option a -> Maybe a

-- | A bifunctor is a type constructor that takes two type arguments and is
--   a functor in <i>both</i> arguments. That is, unlike with
--   <a>Functor</a>, a type constructor such as <a>Either</a> does not need
--   to be partially applied for a <a>Bifunctor</a> instance, and the
--   methods in this class permit mapping functions over the <a>Left</a>
--   value or the <a>Right</a> value, or both at the same time.
--   
--   Formally, the class <a>Bifunctor</a> represents a bifunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where both the first and second
--   arguments are covariant.
--   
--   You can define a <a>Bifunctor</a> by either defining <a>bimap</a> or
--   by defining both <a>first</a> and <a>second</a>.
--   
--   If you supply <a>bimap</a>, you should ensure that:
--   
--   <pre>
--   <a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>first</a> and <a>second</a>, ensure:
--   
--   <pre>
--   <a>first</a> <a>id</a> ≡ <a>id</a>
--   <a>second</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i
--   <a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g
--   <a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g
--   </pre>
class Bifunctor (p :: Type -> Type -> Type)

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) ('j', 3)
--   ('J',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Left 'j')
--   Left 'J'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bimap toUpper (+1) (Right 3)
--   Right 4
--   </pre>
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d

-- | Map covariantly over the first argument.
--   
--   <pre>
--   <a>first</a> f ≡ <a>bimap</a> f <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper ('j', 3)
--   ('J',3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper (Left 'j')
--   Left 'J'
--   </pre>
first :: Bifunctor p => (a -> b) -> p a c -> p b c

-- | Map covariantly over the second argument.
--   
--   <pre>
--   <a>second</a> ≡ <a>bimap</a> <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) ('j', 3)
--   ('j',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) (Right 3)
--   Right 4
--   </pre>
second :: Bifunctor p => (b -> c) -> p a b -> p a c

-- | <a>nonEmpty</a> efficiently turns a normal list into a <a>NonEmpty</a>
--   stream, producing <a>Nothing</a> if the input is empty.
nonEmpty :: () => [a] -> Maybe (NonEmpty a)

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | Calls <a>perror</a> to indicate that there is a type error or similar
--   in the given argument.
errorBadArgument :: () => a

-- | Calls <a>perror</a> to indicate that there is a missing argument in
--   the argument list.
errorMissingArgument :: () => a

-- | Calls <a>perror</a> to indicate that the format string ended early.
errorShortFormat :: () => a

-- | Calls <a>perror</a> to indicate an unknown format letter for a given
--   type.
errorBadFormat :: () => Char -> a

-- | Raises an <a>error</a> with a printf-specific prefix on the message
--   string.
perror :: () => String -> a

-- | Formatter for <a>RealFloat</a> values.
formatRealFloat :: RealFloat a => a -> FieldFormatter

-- | Formatter for <a>Integer</a> values.
formatInteger :: Integer -> FieldFormatter

-- | Formatter for <a>Int</a> values.
formatInt :: (Integral a, Bounded a) => a -> FieldFormatter

-- | Formatter for <a>String</a> values.
formatString :: IsChar a => [a] -> FieldFormatter

-- | Formatter for <a>Char</a> values.
formatChar :: Char -> FieldFormatter

-- | Substitute a 'v' format character with the given default format
--   character in the <a>FieldFormat</a>. A convenience for
--   user-implemented types, which should support "%v".
vFmt :: Char -> FieldFormat -> FieldFormat

-- | Similar to <a>printf</a>, except that output is via the specified
--   <a>Handle</a>. The return type is restricted to <tt>(<a>IO</a>
--   a)</tt>.
hPrintf :: HPrintfType r => Handle -> String -> r

-- | Format a variable number of arguments with the C-style formatting
--   string.
--   
--   <pre>
--   &gt;&gt;&gt; printf "%s, %d, %.4f" "hello" 123 pi
--   hello, 123, 3.1416
--   </pre>
--   
--   The return value is either <a>String</a> or <tt>(<a>IO</a> a)</tt>
--   (which should be <tt>(<a>IO</a> '()')</tt>, but Haskell's type system
--   makes this hard).
--   
--   The format string consists of ordinary characters and <i>conversion
--   specifications</i>, which specify how to format one of the arguments
--   to <a>printf</a> in the output string. A format specification is
--   introduced by the <tt>%</tt> character; this character can be
--   self-escaped into the format string using <tt>%%</tt>. A format
--   specification ends with a /format character/ that provides the primary
--   information about how to format the value. The rest of the conversion
--   specification is optional. In order, one may have flag characters, a
--   width specifier, a precision specifier, and type-specific modifier
--   characters.
--   
--   Unlike C <tt>printf(3)</tt>, the formatting of this <a>printf</a> is
--   driven by the argument type; formatting is type specific. The types
--   formatted by <a>printf</a> "out of the box" are:
--   
--   <ul>
--   <li><a>Integral</a> types, including <a>Char</a></li>
--   <li><a>String</a></li>
--   <li><a>RealFloat</a> types</li>
--   </ul>
--   
--   <a>printf</a> is also extensible to support other types: see below.
--   
--   A conversion specification begins with the character <tt>%</tt>,
--   followed by zero or more of the following flags:
--   
--   <pre>
--   -      left adjust (default is right adjust)
--   +      always use a sign (+ or -) for signed conversions
--   space  leading space for positive numbers in signed conversions
--   0      pad with zeros rather than spaces
--   #      use an \"alternate form\": see below
--   </pre>
--   
--   When both flags are given, <tt>-</tt> overrides <tt>0</tt> and
--   <tt>+</tt> overrides space. A negative width specifier in a <tt>*</tt>
--   conversion is treated as positive but implies the left adjust flag.
--   
--   The "alternate form" for unsigned radix conversions is as in C
--   <tt>printf(3)</tt>:
--   
--   <pre>
--   %o           prefix with a leading 0 if needed
--   %x           prefix with a leading 0x if nonzero
--   %X           prefix with a leading 0X if nonzero
--   %b           prefix with a leading 0b if nonzero
--   %[eEfFgG]    ensure that the number contains a decimal point
--   </pre>
--   
--   Any flags are followed optionally by a field width:
--   
--   <pre>
--   num    field width
--   *      as num, but taken from argument list
--   </pre>
--   
--   The field width is a minimum, not a maximum: it will be expanded as
--   needed to avoid mutilating a value.
--   
--   Any field width is followed optionally by a precision:
--   
--   <pre>
--   .num   precision
--   .      same as .0
--   .*     as num, but taken from argument list
--   </pre>
--   
--   Negative precision is taken as 0. The meaning of the precision depends
--   on the conversion type.
--   
--   <pre>
--   Integral    minimum number of digits to show
--   RealFloat   number of digits after the decimal point
--   String      maximum number of characters
--   </pre>
--   
--   The precision for Integral types is accomplished by zero-padding. If
--   both precision and zero-pad are given for an Integral field, the
--   zero-pad is ignored.
--   
--   Any precision is followed optionally for Integral types by a width
--   modifier; the only use of this modifier being to set the implicit size
--   of the operand for conversion of a negative operand to unsigned:
--   
--   <pre>
--   hh     Int8
--   h      Int16
--   l      Int32
--   ll     Int64
--   L      Int64
--   </pre>
--   
--   The specification ends with a format character:
--   
--   <pre>
--   c      character               Integral
--   d      decimal                 Integral
--   o      octal                   Integral
--   x      hexadecimal             Integral
--   X      hexadecimal             Integral
--   b      binary                  Integral
--   u      unsigned decimal        Integral
--   f      floating point          RealFloat
--   F      floating point          RealFloat
--   g      general format float    RealFloat
--   G      general format float    RealFloat
--   e      exponent format float   RealFloat
--   E      exponent format float   RealFloat
--   s      string                  String
--   v      default format          any type
--   </pre>
--   
--   The "%v" specifier is provided for all built-in types, and should be
--   provided for user-defined type formatters as well. It picks a "best"
--   representation for the given type. For the built-in types the "%v"
--   specifier is converted as follows:
--   
--   <pre>
--   c      Char
--   u      other unsigned Integral
--   d      other signed Integral
--   g      RealFloat
--   s      String
--   </pre>
--   
--   Mismatch between the argument types and the format string, as well as
--   any other syntactic or semantic errors in the format string, will
--   cause an exception to be thrown at runtime.
--   
--   Note that the formatting for <a>RealFloat</a> types is currently a bit
--   different from that of C <tt>printf(3)</tt>, conforming instead to
--   <a>showEFloat</a>, <a>showFFloat</a> and <a>showGFloat</a> (and their
--   alternate versions <a>showFFloatAlt</a> and <a>showGFloatAlt</a>).
--   This is hard to fix: the fixed versions would format in a
--   backward-incompatible way. In any case the Haskell behavior is
--   generally more sensible than the C behavior. A brief summary of some
--   key differences:
--   
--   <ul>
--   <li>Haskell <a>printf</a> never uses the default "6-digit" precision
--   used by C printf.</li>
--   <li>Haskell <a>printf</a> treats the "precision" specifier as
--   indicating the number of digits after the decimal point.</li>
--   <li>Haskell <a>printf</a> prints the exponent of e-format numbers
--   without a gratuitous plus sign, and with the minimum possible number
--   of digits.</li>
--   <li>Haskell <a>printf</a> will place a zero after a decimal point when
--   possible.</li>
--   </ul>
printf :: PrintfType r => String -> r

-- | The <a>PrintfType</a> class provides the variable argument magic for
--   <a>printf</a>. Its implementation is intentionally not visible from
--   this module. If you attempt to pass an argument of a type which is not
--   an instance of this class to <a>printf</a> or <a>hPrintf</a>, then the
--   compiler will report it as a missing instance of <a>PrintfArg</a>.
class PrintfType t

-- | The <a>HPrintfType</a> class provides the variable argument magic for
--   <a>hPrintf</a>. Its implementation is intentionally not visible from
--   this module.
class HPrintfType t

-- | Typeclass of <a>printf</a>-formattable values. The <a>formatArg</a>
--   method takes a value and a field format descriptor and either fails
--   due to a bad descriptor or produces a <a>ShowS</a> as the result. The
--   default <a>parseFormat</a> expects no modifiers: this is the normal
--   case. Minimal instance: <a>formatArg</a>.
class PrintfArg a

formatArg :: PrintfArg a => a -> FieldFormatter

parseFormat :: PrintfArg a => a -> ModifierParser

-- | This class, with only the one instance, is used as a workaround for
--   the fact that <a>String</a>, as a concrete type, is not allowable as a
--   typeclass instance. <a>IsChar</a> is exported for
--   backward-compatibility.
class IsChar c

toChar :: IsChar c => c -> Char

fromChar :: IsChar c => Char -> c

-- | Whether to left-adjust or zero-pad a field. These are mutually
--   exclusive, with <a>LeftAdjust</a> taking precedence.
data FormatAdjustment
LeftAdjust :: FormatAdjustment
ZeroPad :: FormatAdjustment

-- | How to handle the sign of a numeric field. These are mutually
--   exclusive, with <a>SignPlus</a> taking precedence.
data FormatSign
SignPlus :: FormatSign
SignSpace :: FormatSign

-- | Description of field formatting for <a>formatArg</a>. See UNIX
--   <a>printf</a>(3) for a description of how field formatting works.
data FieldFormat
FieldFormat :: Maybe Int -> Maybe Int -> Maybe FormatAdjustment -> Maybe FormatSign -> Bool -> String -> Char -> FieldFormat

-- | Total width of the field.
[fmtWidth] :: FieldFormat -> Maybe Int

-- | Secondary field width specifier.
[fmtPrecision] :: FieldFormat -> Maybe Int

-- | Kind of filling or padding to be done.
[fmtAdjust] :: FieldFormat -> Maybe FormatAdjustment

-- | Whether to insist on a plus sign for positive numbers.
[fmtSign] :: FieldFormat -> Maybe FormatSign

-- | Indicates an "alternate format". See printf(3) for the details, which
--   vary by argument spec.
[fmtAlternate] :: FieldFormat -> Bool

-- | Characters that appeared immediately to the left of <a>fmtChar</a> in
--   the format and were accepted by the type's <a>parseFormat</a>.
--   Normally the empty string.
[fmtModifiers] :: FieldFormat -> String

-- | The format character <a>printf</a> was invoked with. <a>formatArg</a>
--   should fail unless this character matches the type. It is normal to
--   handle many different format characters for a single type.
[fmtChar] :: FieldFormat -> Char

-- | The "format parser" walks over argument-type-specific modifier
--   characters to find the primary format character. This is the type of
--   its result.
data FormatParse
FormatParse :: String -> Char -> String -> FormatParse

-- | Any modifiers found.
[fpModifiers] :: FormatParse -> String

-- | Primary format character.
[fpChar] :: FormatParse -> Char

-- | Rest of the format string.
[fpRest] :: FormatParse -> String

-- | This is the type of a field formatter reified over its argument.
type FieldFormatter = FieldFormat -> ShowS

-- | Type of a function that will parse modifier characters from the format
--   string.
type ModifierParser = String -> FormatParse

-- | The <a>traceMarkerIO</a> function emits a marker to the eventlog, if
--   eventlog profiling is available and enabled at runtime.
--   
--   Compared to <a>traceMarker</a>, <a>traceMarkerIO</a> sequences the
--   event with respect to other IO actions.
traceMarkerIO :: String -> IO ()

-- | The <a>traceMarker</a> function emits a marker to the eventlog, if
--   eventlog profiling is available and enabled at runtime. The
--   <tt>String</tt> is the name of the marker. The name is just used in
--   the profiling tools to help you keep clear which marker is which.
--   
--   This function is suitable for use in pure code. In an IO context use
--   <a>traceMarkerIO</a> instead.
--   
--   Note that when using GHC's SMP runtime, it is possible (but rare) to
--   get duplicate events emitted if two CPUs simultaneously evaluate the
--   same thunk that uses <a>traceMarker</a>.
traceMarker :: () => String -> a -> a

-- | The <a>traceEventIO</a> function emits a message to the eventlog, if
--   eventlog profiling is available and enabled at runtime.
--   
--   Compared to <a>traceEvent</a>, <a>traceEventIO</a> sequences the event
--   with respect to other IO actions.
traceEventIO :: String -> IO ()

-- | The <a>traceEvent</a> function behaves like <a>trace</a> with the
--   difference that the message is emitted to the eventlog, if eventlog
--   profiling is available and enabled at runtime.
--   
--   It is suitable for use in pure code. In an IO context use
--   <a>traceEventIO</a> instead.
--   
--   Note that when using GHC's SMP runtime, it is possible (but rare) to
--   get duplicate events emitted if two CPUs simultaneously evaluate the
--   same thunk that uses <a>traceEvent</a>.
traceEvent :: () => String -> a -> a

-- | like <a>trace</a>, but additionally prints a call stack if one is
--   available.
--   
--   In the current GHC implementation, the call stack is only available if
--   the program was compiled with <tt>-prof</tt>; otherwise
--   <a>traceStack</a> behaves exactly like <a>trace</a>. Entries in the
--   call stack correspond to <tt>SCC</tt> annotations, so it is a good
--   idea to use <tt>-fprof-auto</tt> or <tt>-fprof-auto-calls</tt> to add
--   SCC annotations automatically.
traceStack :: () => String -> a -> a

-- | Like <a>traceM</a>, but uses <a>show</a> on the argument to convert it
--   to a <a>String</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   do
--       x &lt;- Just 3
--       traceShowM x
--       y &lt;- pure 12
--       traceShowM y
--       pure (x*2 + y)
--   :}
--   3
--   12
--   Just 18
--   </pre>
traceShowM :: (Show a, Applicative f) => a -> f ()

-- | Like <a>trace</a> but returning unit in an arbitrary
--   <a>Applicative</a> context. Allows for convenient use in do-notation.
--   
--   Note that the application of <a>traceM</a> is not an action in the
--   <a>Applicative</a> context, as <a>traceIO</a> is in the <a>IO</a>
--   type. While the fresh bindings in the following example will force the
--   <a>traceM</a> expressions to be reduced every time the
--   <tt>do</tt>-block is executed, <tt>traceM "not crashed"</tt> would
--   only be reduced once, and the message would only be printed once. If
--   your monad is in <tt>MonadIO</tt>, <tt>liftIO . traceIO</tt> may be a
--   better option.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   do
--       x &lt;- Just 3
--       traceM ("x: " ++ show x)
--       y &lt;- pure 12
--       traceM ("y: " ++ show y)
--       pure (x*2 + y)
--   :}
--   x: 3
--   y: 12
--   Just 18
--   </pre>
traceM :: Applicative f => String -> f ()

-- | Like <a>traceShow</a> but returns the shown value instead of a third
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; traceShowId (1+2+3, "hello" ++ "world")
--   (6,"helloworld")
--   (6,"helloworld")
--   </pre>
traceShowId :: Show a => a -> a

-- | Like <a>trace</a>, but uses <a>show</a> on the argument to convert it
--   to a <a>String</a>.
--   
--   This makes it convenient for printing the values of interesting
--   variables or expressions inside a function. For example here we print
--   the value of the variables <tt>x</tt> and <tt>y</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let f x y = traceShow (x,y) (x + y) in f (1+2) 5
--   (3,5)
--   8
--   </pre>
traceShow :: Show a => a -> b -> b

-- | Like <a>trace</a> but returns the message instead of a third value.
--   
--   <pre>
--   &gt;&gt;&gt; traceId "hello"
--   "hello
--   hello"
--   </pre>
traceId :: String -> String

putTraceMsg :: String -> IO ()

-- | The <a>traceIO</a> function outputs the trace message from the IO
--   monad. This sequences the output with respect to other IO actions.
traceIO :: String -> IO ()

-- | The <a>isSubsequenceOf</a> function takes two lists and returns
--   <a>True</a> if all the elements of the first list occur, in order, in
--   the second. The elements do not have to occur consecutively.
--   
--   <tt><a>isSubsequenceOf</a> x y</tt> is equivalent to <tt><a>elem</a> x
--   (<a>subsequences</a> y)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; isSubsequenceOf "GHC" "The Glorious Haskell Compiler"
--   True
--   
--   &gt;&gt;&gt; isSubsequenceOf ['a','d'..'z'] ['a'..'z']
--   True
--   
--   &gt;&gt;&gt; isSubsequenceOf [1..10] [10,9..0]
--   False
--   </pre>
isSubsequenceOf :: Eq a => [a] -> [a] -> Bool

-- | This function may be used as a value for <a>foldMap</a> in a
--   <a>Foldable</a> instance.
--   
--   <pre>
--   <a>foldMapDefault</a> f ≡ <a>getConst</a> . <a>traverse</a> (<a>Const</a> . f)
--   </pre>
foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m

-- | This function may be used as a value for <a>fmap</a> in a
--   <a>Functor</a> instance, provided that <a>traverse</a> is defined.
--   (Using <a>fmapDefault</a> with a <a>Traversable</a> instance defined
--   only by <a>sequenceA</a> will result in infinite recursion.)
--   
--   <pre>
--   <a>fmapDefault</a> f ≡ <a>runIdentity</a> . <a>traverse</a> (<a>Identity</a> . f)
--   </pre>
fmapDefault :: Traversable t => (a -> b) -> t a -> t b

-- | The <a>mapAccumR</a> function behaves like a combination of
--   <a>fmap</a> and <tt>foldr</tt>; it applies a function to each element
--   of a structure, passing an accumulating parameter from right to left,
--   and returning a final value of this accumulator together with the new
--   structure.
mapAccumR :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)

-- | The <a>mapAccumL</a> function behaves like a combination of
--   <a>fmap</a> and <tt>foldl</tt>; it applies a function to each element
--   of a structure, passing an accumulating parameter from left to right,
--   and returning a final value of this accumulator together with the new
--   structure.
mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a

-- | The sum of a collection of actions, generalizing <a>concat</a>.
--   
--   asum [Just <a>Hello</a>, Nothing, Just <a>World</a>] Just <a>Hello</a>
asum :: (Foldable t, Alternative f) => t (f a) -> f a

-- | Evaluate each action in the structure from left to right, and ignore
--   the results. For a version that doesn't ignore the results see
--   <a>sequenceA</a>.
sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()

-- | Monadic fold over the elements of a structure, associating to the
--   left, i.e. from left to right.
foldlM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Monadic fold over the elements of a structure, associating to the
--   right, i.e. from right to left.
foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b

-- | This is a valid definition of <a>stimes</a> for a <a>Monoid</a>.
--   
--   Unlike the default definition of <a>stimes</a>, it is defined for 0
--   and so it should be preferred where possible.
stimesMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Semigroup</a>.
--   
--   When <tt>x &lt;&gt; x = x</tt>, this definition should be preferred,
--   because it works in <i>O(1)</i> rather than <i>O(log n)</i>.
stimesIdempotent :: Integral b => b -> a -> a

-- | The dual of a <a>Monoid</a>, obtained by swapping the arguments of
--   <a>mappend</a>.
--   
--   <pre>
--   &gt;&gt;&gt; getDual (mappend (Dual "Hello") (Dual "World"))
--   "WorldHello"
--   </pre>
newtype Dual a
Dual :: a -> Dual a
[getDual] :: Dual a -> a

-- | The monoid of endomorphisms under composition.
--   
--   <pre>
--   &gt;&gt;&gt; let computation = Endo ("Hello, " ++) &lt;&gt; Endo (++ "!")
--   
--   &gt;&gt;&gt; appEndo computation "Haskell"
--   "Hello, Haskell!"
--   </pre>
newtype Endo a
Endo :: (a -> a) -> Endo a
[appEndo] :: Endo a -> a -> a

-- | Monoid under addition.
--   
--   <pre>
--   &gt;&gt;&gt; getSum (Sum 1 &lt;&gt; Sum 2 &lt;&gt; mempty)
--   3
--   </pre>
newtype Sum a
Sum :: a -> Sum a
[getSum] :: Sum a -> a

-- | Monoid under multiplication.
--   
--   <pre>
--   &gt;&gt;&gt; getProduct (Product 3 &lt;&gt; Product 4 &lt;&gt; mempty)
--   12
--   </pre>
newtype Product a
Product :: a -> Product a
[getProduct] :: Product a -> a

-- | Sort a list by comparing the results of a key function applied to each
--   element. <tt>sortOn f</tt> is equivalent to <tt>sortBy (comparing
--   f)</tt>, but has the performance advantage of only evaluating
--   <tt>f</tt> once for each element in the input list. This is called the
--   decorate-sort-undecorate paradigm, or Schwartzian transform.
--   
--   Elements are arranged from from lowest to highest, keeping duplicates
--   in the order they appeared in the input.
--   
--   <pre>
--   &gt;&gt;&gt; sortOn fst [(2, "world"), (4, "!"), (1, "Hello")]
--   [(1,"Hello"),(2,"world"),(4,"!")]
--   </pre>
sortOn :: Ord b => (a -> b) -> [a] -> [a]

-- | The <a>permutations</a> function returns the list of all permutations
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; permutations "abc"
--   ["abc","bac","cba","bca","cab","acb"]
--   </pre>
permutations :: () => [a] -> [[a]]

-- | The <a>subsequences</a> function returns the list of all subsequences
--   of the argument.
--   
--   <pre>
--   &gt;&gt;&gt; subsequences "abc"
--   ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
subsequences :: () => [a] -> [[a]]

-- | The <a>tails</a> function returns all final segments of the argument,
--   longest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; tails "abc"
--   ["abc","bc","c",""]
--   </pre>
--   
--   Note that <a>tails</a> has the following strictness property:
--   <tt>tails _|_ = _|_ : _|_</tt>
tails :: () => [a] -> [[a]]

-- | The <a>inits</a> function returns all initial segments of the
--   argument, shortest first. For example,
--   
--   <pre>
--   &gt;&gt;&gt; inits "abc"
--   ["","a","ab","abc"]
--   </pre>
--   
--   Note that <a>inits</a> has the following strictness property:
--   <tt>inits (xs ++ _|_) = inits xs ++ _|_</tt>
--   
--   In particular, <tt>inits _|_ = [] : _|_</tt>
inits :: () => [a] -> [[a]]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
groupBy :: () => (a -> a -> Bool) -> [a] -> [[a]]

-- | The <a>group</a> function takes a list and returns a list of lists
--   such that the concatenation of the result is equal to the argument.
--   Moreover, each sublist in the result contains only equal elements. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; group "Mississippi"
--   ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   It is a special case of <a>groupBy</a>, which allows the programmer to
--   supply their own equality test.
group :: Eq a => [a] -> [[a]]

-- | The <a>deleteFirstsBy</a> function takes a predicate and two lists and
--   returns the first list with the first occurrence of each element of
--   the second list removed.
deleteFirstsBy :: () => (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>unzip7</a> function takes a list of seven-tuples and returns
--   seven lists, analogous to <a>unzip</a>.
unzip7 :: () => [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])

-- | The <a>unzip6</a> function takes a list of six-tuples and returns six
--   lists, analogous to <a>unzip</a>.
unzip6 :: () => [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])

-- | The <a>unzip5</a> function takes a list of five-tuples and returns
--   five lists, analogous to <a>unzip</a>.
unzip5 :: () => [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])

-- | The <a>unzip4</a> function takes a list of quadruples and returns four
--   lists, analogous to <a>unzip</a>.
unzip4 :: () => [(a, b, c, d)] -> ([a], [b], [c], [d])

-- | The <a>zipWith7</a> function takes a function which combines seven
--   elements, as well as seven lists and returns a list of their
--   point-wise combination, analogous to <a>zipWith</a>.
zipWith7 :: () => (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]

-- | The <a>zipWith6</a> function takes a function which combines six
--   elements, as well as six lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>.
zipWith6 :: () => (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]

-- | The <a>zipWith5</a> function takes a function which combines five
--   elements, as well as five lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>.
zipWith5 :: () => (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]

-- | The <a>zipWith4</a> function takes a function which combines four
--   elements, as well as four lists and returns a list of their point-wise
--   combination, analogous to <a>zipWith</a>.
zipWith4 :: () => (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]

-- | The <a>zip7</a> function takes seven lists and returns a list of
--   seven-tuples, analogous to <a>zip</a>.
zip7 :: () => [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]

-- | The <a>zip6</a> function takes six lists and returns a list of
--   six-tuples, analogous to <a>zip</a>.
zip6 :: () => [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]

-- | The <a>zip5</a> function takes five lists and returns a list of
--   five-tuples, analogous to <a>zip</a>.
zip5 :: () => [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]

-- | The <a>zip4</a> function takes four lists and returns a list of
--   quadruples, analogous to <a>zip</a>.
zip4 :: () => [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]

-- | The <a>genericReplicate</a> function is an overloaded version of
--   <a>replicate</a>, which accepts any <a>Integral</a> value as the
--   number of repetitions to make.
genericReplicate :: Integral i => i -> a -> [a]

-- | The <a>genericIndex</a> function is an overloaded version of
--   <a>!!</a>, which accepts any <a>Integral</a> value as the index.
genericIndex :: Integral i => [a] -> i -> a

-- | The <a>genericSplitAt</a> function is an overloaded version of
--   <a>splitAt</a>, which accepts any <a>Integral</a> value as the
--   position at which to split.
genericSplitAt :: Integral i => i -> [a] -> ([a], [a])

-- | The <a>genericDrop</a> function is an overloaded version of
--   <a>drop</a>, which accepts any <a>Integral</a> value as the number of
--   elements to drop.
genericDrop :: Integral i => i -> [a] -> [a]

-- | The <a>genericTake</a> function is an overloaded version of
--   <a>take</a>, which accepts any <a>Integral</a> value as the number of
--   elements to take.
genericTake :: Integral i => i -> [a] -> [a]

-- | The <a>genericLength</a> function is an overloaded version of
--   <a>length</a>. In particular, instead of returning an <a>Int</a>, it
--   returns any type which is an instance of <a>Num</a>. It is, however,
--   less efficient than <a>length</a>.
genericLength :: Num i => [a] -> i

-- | The non-overloaded version of <a>insert</a>.
insertBy :: () => (a -> a -> Ordering) -> a -> [a] -> [a]

-- | The <a>insert</a> function takes an element and a list and inserts the
--   element into the list at the first position where it is less than or
--   equal to the next element. In particular, if the list is sorted before
--   the call, the result will also be sorted. It is a special case of
--   <a>insertBy</a>, which allows the programmer to supply their own
--   comparison function.
--   
--   <pre>
--   &gt;&gt;&gt; insert 4 [1,2,3,5,6,7]
--   [1,2,3,4,5,6,7]
--   </pre>
insert :: Ord a => a -> [a] -> [a]

-- | The <a>partition</a> function takes a predicate a list and returns the
--   pair of lists of elements which do and do not satisfy the predicate,
--   respectively; i.e.,
--   
--   <pre>
--   partition p xs == (filter p xs, filter (not . p) xs)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; partition (`elem` "aeiou") "Hello World!"
--   ("eoo","Hll Wrld!")
--   </pre>
partition :: () => (a -> Bool) -> [a] -> ([a], [a])

-- | The <a>transpose</a> function transposes the rows and columns of its
--   argument. For example,
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[1,2,3],[4,5,6]]
--   [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   If some of the rows are shorter than the following rows, their
--   elements are skipped:
--   
--   <pre>
--   &gt;&gt;&gt; transpose [[10,11],[20],[],[30,31,32]]
--   [[10,20,30],[11,31],[32]]
--   </pre>
transpose :: () => [[a]] -> [[a]]

-- | The <a>intersectBy</a> function is the non-overloaded version of
--   <a>intersect</a>.
intersectBy :: () => (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>intersect</a> function takes the list intersection of two
--   lists. For example,
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] `intersect` [2,4,6,8]
--   [2,4]
--   </pre>
--   
--   If the first list contains duplicates, so will the result.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,2,3,4] `intersect` [6,4,4,2]
--   [2,2,4]
--   </pre>
--   
--   It is a special case of <a>intersectBy</a>, which allows the
--   programmer to supply their own equality test. If the element is found
--   in both the first and the second list, the element from the first list
--   will be used.
intersect :: Eq a => [a] -> [a] -> [a]

-- | The <a>unionBy</a> function is the non-overloaded version of
--   <a>union</a>.
unionBy :: () => (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | The <a>union</a> function returns the list union of the two lists. For
--   example,
--   
--   <pre>
--   &gt;&gt;&gt; "dog" `union` "cow"
--   "dogcw"
--   </pre>
--   
--   Duplicates, and elements of the first list, are removed from the the
--   second list, but if the first list contains duplicates, so will the
--   result. It is a special case of <a>unionBy</a>, which allows the
--   programmer to supply their own equality test.
union :: Eq a => [a] -> [a] -> [a]

-- | The <a>\\</a> function is list difference (non-associative). In the
--   result of <tt>xs</tt> <a>\\</a> <tt>ys</tt>, the first occurrence of
--   each element of <tt>ys</tt> in turn (if any) has been removed from
--   <tt>xs</tt>. Thus
--   
--   <pre>
--   (xs ++ ys) \\ xs == ys.
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "Hello World!" \\ "ell W"
--   "Hoorld!"
--   </pre>
--   
--   It is a special case of <a>deleteFirstsBy</a>, which allows the
--   programmer to supply their own equality test.
(\\) :: Eq a => [a] -> [a] -> [a]
infix 5 \\

-- | The <a>deleteBy</a> function behaves like <a>delete</a>, but takes a
--   user-supplied equality predicate.
--   
--   <pre>
--   &gt;&gt;&gt; deleteBy (&lt;=) 4 [1..10]
--   [1,2,3,5,6,7,8,9,10]
--   </pre>
deleteBy :: () => (a -> a -> Bool) -> a -> [a] -> [a]

-- | <a>delete</a> <tt>x</tt> removes the first occurrence of <tt>x</tt>
--   from its list argument. For example,
--   
--   <pre>
--   &gt;&gt;&gt; delete 'a' "banana"
--   "bnana"
--   </pre>
--   
--   It is a special case of <a>deleteBy</a>, which allows the programmer
--   to supply their own equality test.
delete :: Eq a => a -> [a] -> [a]

-- | The <a>findIndices</a> function extends <a>findIndex</a>, by returning
--   the indices of all elements satisfying the predicate, in ascending
--   order.
--   
--   <pre>
--   &gt;&gt;&gt; findIndices (`elem` "aeiou") "Hello World!"
--   [1,4,7]
--   </pre>
findIndices :: () => (a -> Bool) -> [a] -> [Int]

-- | The <a>findIndex</a> function takes a predicate and a list and returns
--   the index of the first element in the list satisfying the predicate,
--   or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   &gt;&gt;&gt; findIndex isSpace "Hello World!"
--   Just 5
--   </pre>
findIndex :: () => (a -> Bool) -> [a] -> Maybe Int

-- | The <a>elemIndices</a> function extends <a>elemIndex</a>, by returning
--   the indices of all elements equal to the query element, in ascending
--   order.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndices 'o' "Hello World"
--   [4,7]
--   </pre>
elemIndices :: Eq a => a -> [a] -> [Int]

-- | The <a>elemIndex</a> function returns the index of the first element
--   in the given list which is equal (by <a>==</a>) to the query element,
--   or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   &gt;&gt;&gt; elemIndex 4 [0..]
--   Just 4
--   </pre>
elemIndex :: Eq a => a -> [a] -> Maybe Int

-- | The <a>stripPrefix</a> function drops the given prefix from a list. It
--   returns <a>Nothing</a> if the list did not start with the prefix
--   given, or <a>Just</a> the list after the prefix, if it does.
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foobar"
--   Just "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "foo"
--   Just ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoo"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; stripPrefix "foo" "barfoobaz"
--   Nothing
--   </pre>
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]

-- | The <a>dropWhileEnd</a> function drops the largest suffix of a list in
--   which the given predicate holds for all elements. For example:
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo\n"
--   "foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileEnd isSpace "foo bar"
--   "foo bar"
--   </pre>
--   
--   <pre>
--   dropWhileEnd isSpace ("foo\n" ++ undefined) == "foo" ++ undefined
--   </pre>
dropWhileEnd :: () => (a -> Bool) -> [a] -> [a]

-- | Selects Unicode space and separator characters.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>Space</a></li>
--   <li><a>LineSeparator</a></li>
--   <li><a>ParagraphSeparator</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Separator".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator 'a'
--   False
--   
--   &gt;&gt;&gt; isSeparator '6'
--   False
--   
--   &gt;&gt;&gt; isSeparator ' '
--   True
--   </pre>
--   
--   Warning: newlines and tab characters are not considered separators.
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator '\n'
--   False
--   
--   &gt;&gt;&gt; isSeparator '\t'
--   False
--   </pre>
--   
--   But some more exotic characters are (like HTML's <tt>&amp;nbsp;</tt>):
--   
--   <pre>
--   &gt;&gt;&gt; isSeparator '\160'
--   True
--   </pre>
isSeparator :: Char -> Bool

-- | Selects Unicode numeric characters, including digits from various
--   scripts, Roman numerals, et cetera.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>DecimalNumber</a></li>
--   <li><a>LetterNumber</a></li>
--   <li><a>OtherNumber</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Number".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNumber 'a'
--   False
--   
--   &gt;&gt;&gt; isNumber '%'
--   False
--   
--   &gt;&gt;&gt; isNumber '3'
--   True
--   </pre>
--   
--   ASCII <tt>'0'</tt> through <tt>'9'</tt> are all numbers:
--   
--   <pre>
--   &gt;&gt;&gt; and $ map isNumber ['0'..'9']
--   True
--   </pre>
--   
--   Unicode Roman numerals are "numbers" as well:
--   
--   <pre>
--   &gt;&gt;&gt; isNumber 'Ⅸ'
--   True
--   </pre>
isNumber :: Char -> Bool

-- | Selects Unicode mark characters, for example accents and the like,
--   which combine with preceding characters.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>NonSpacingMark</a></li>
--   <li><a>SpacingCombiningMark</a></li>
--   <li><a>EnclosingMark</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Mark".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isMark 'a'
--   False
--   
--   &gt;&gt;&gt; isMark '0'
--   False
--   </pre>
--   
--   Combining marks such as accent characters usually need to follow
--   another character before they become printable:
--   
--   <pre>
--   &gt;&gt;&gt; map isMark "ò"
--   [False,True]
--   </pre>
--   
--   Puns are not necessarily supported:
--   
--   <pre>
--   &gt;&gt;&gt; isMark '✓'
--   False
--   </pre>
isMark :: Char -> Bool

-- | Selects alphabetic Unicode characters (lower-case, upper-case and
--   title-case letters, plus letters of caseless scripts and modifiers
--   letters). This function is equivalent to <a>isAlpha</a>.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>UppercaseLetter</a></li>
--   <li><a>LowercaseLetter</a></li>
--   <li><a>TitlecaseLetter</a></li>
--   <li><a>ModifierLetter</a></li>
--   <li><a>OtherLetter</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Letter".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLetter 'a'
--   True
--   
--   &gt;&gt;&gt; isLetter 'A'
--   True
--   
--   &gt;&gt;&gt; isLetter 'λ'
--   True
--   
--   &gt;&gt;&gt; isLetter '0'
--   False
--   
--   &gt;&gt;&gt; isLetter '%'
--   False
--   
--   &gt;&gt;&gt; isLetter '♥'
--   False
--   
--   &gt;&gt;&gt; isLetter '\31'
--   False
--   </pre>
--   
--   Ensure that <a>isLetter</a> and <a>isAlpha</a> are equivalent.
--   
--   <pre>
--   &gt;&gt;&gt; let chars = [(chr 0)..]
--   
--   &gt;&gt;&gt; let letters = map isLetter chars
--   
--   &gt;&gt;&gt; let alphas = map isAlpha chars
--   
--   &gt;&gt;&gt; letters == alphas
--   True
--   </pre>
isLetter :: Char -> Bool

-- | Convert a single digit <a>Char</a> to the corresponding <a>Int</a>.
--   This function fails unless its argument satisfies <a>isHexDigit</a>,
--   but recognises both upper- and lower-case hexadecimal digits (that is,
--   <tt>'0'</tt>..<tt>'9'</tt>, <tt>'a'</tt>..<tt>'f'</tt>,
--   <tt>'A'</tt>..<tt>'F'</tt>).
--   
--   <h4><b>Examples</b></h4>
--   
--   Characters <tt>'0'</tt> through <tt>'9'</tt> are converted properly to
--   <tt>0..9</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; map digitToInt ['0'..'9']
--   [0,1,2,3,4,5,6,7,8,9]
--   </pre>
--   
--   Both upper- and lower-case <tt>'A'</tt> through <tt>'F'</tt> are
--   converted as well, to <tt>10..15</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; map digitToInt ['a'..'f']
--   [10,11,12,13,14,15]
--   
--   &gt;&gt;&gt; map digitToInt ['A'..'F']
--   [10,11,12,13,14,15]
--   </pre>
--   
--   Anything else throws an exception:
--   
--   <pre>
--   &gt;&gt;&gt; digitToInt 'G'
--   *** Exception: Char.digitToInt: not a digit 'G'
--   
--   &gt;&gt;&gt; digitToInt '♥'
--   *** Exception: Char.digitToInt: not a digit '\9829'
--   </pre>
digitToInt :: Char -> Int

-- | Return the contents of a <a>Right</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromRight 1 (Right 3)
--   3
--   
--   &gt;&gt;&gt; fromRight 1 (Left "foo")
--   1
--   </pre>
fromRight :: () => b -> Either a b -> b

-- | Return the contents of a <a>Left</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromLeft 1 (Left 3)
--   3
--   
--   &gt;&gt;&gt; fromLeft 1 (Right "foo")
--   1
--   </pre>
fromLeft :: () => a -> Either a b -> a

-- | Return <a>True</a> if the given value is a <a>Right</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isRight (Left "foo")
--   False
--   
--   &gt;&gt;&gt; isRight (Right 3)
--   True
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isRight</a> to write a very simple reporting function that only
--   outputs "SUCCESS" when a computation has succeeded.
--   
--   This example shows how <a>isRight</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isRight e) $ putStrLn "SUCCESS"
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   
--   &gt;&gt;&gt; report (Right 1)
--   SUCCESS
--   </pre>
isRight :: () => Either a b -> Bool

-- | Return <a>True</a> if the given value is a <a>Left</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLeft (Left "foo")
--   True
--   
--   &gt;&gt;&gt; isLeft (Right 3)
--   False
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isLeft</a> to write a very simple error-reporting function that
--   does absolutely nothing in the case of success, and outputs "ERROR" if
--   any error occurred.
--   
--   This example shows how <a>isLeft</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isLeft e) $ putStrLn "ERROR"
--   
--   &gt;&gt;&gt; report (Right 1)
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   ERROR
--   </pre>
isLeft :: () => Either a b -> Bool

-- | Partitions a list of <a>Either</a> into two lists. All the <a>Left</a>
--   elements are extracted, in order, to the first component of the
--   output. Similarly the <a>Right</a> elements are extracted to the
--   second component of the output.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list
--   (["foo","bar","baz"],[3,7])
--   </pre>
--   
--   The pair returned by <tt><a>partitionEithers</a> x</tt> should be the
--   same pair as <tt>(<a>lefts</a> x, <a>rights</a> x)</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list == (lefts list, rights list)
--   True
--   </pre>
partitionEithers :: () => [Either a b] -> ([a], [b])

-- | Extracts from a list of <a>Either</a> all the <a>Right</a> elements.
--   All the <a>Right</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; rights list
--   [3,7]
--   </pre>
rights :: () => [Either a b] -> [b]

-- | Extracts from a list of <a>Either</a> all the <a>Left</a> elements.
--   All the <a>Left</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; lefts list
--   ["foo","bar","baz"]
--   </pre>
lefts :: () => [Either a b] -> [a]

-- | The <a>Down</a> type allows you to reverse sort order conveniently. A
--   value of type <tt><a>Down</a> a</tt> contains a value of type
--   <tt>a</tt> (represented as <tt><a>Down</a> a</tt>). If <tt>a</tt> has
--   an <tt><a>Ord</a></tt> instance associated with it then comparing two
--   values thus wrapped will give you the opposite of their normal sort
--   order. This is particularly useful when sorting in generalised list
--   comprehensions, as in: <tt>then sortWith by <a>Down</a> x</tt>
newtype Down a
Down :: a -> Down a

-- | Read a string representation of a character, using Haskell
--   source-language escape conventions, and convert it to the character
--   that it encodes. For example:
--   
--   <pre>
--   readLitChar "\\nHello"  =  [('\n', "Hello")]
--   </pre>
readLitChar :: ReadS Char

-- | Read a string representation of a character, using Haskell
--   source-language escape conventions. For example:
--   
--   <pre>
--   lexLitChar  "\\nHello"  =  [("\\n", "Hello")]
--   </pre>
lexLitChar :: ReadS String

-- | Convert a letter to the corresponding title-case or upper-case letter,
--   if any. (Title case differs from upper case only for a small number of
--   ligature letters.) Any other character is returned unchanged.
toTitle :: Char -> Char

-- | Selects lower-case alphabetic Unicode characters (letters).
isLower :: Char -> Bool

-- | Selects printable Unicode characters (letters, numbers, marks,
--   punctuation, symbols and spaces).
isPrint :: Char -> Bool

-- | Selects control characters, which are the non-printing characters of
--   the Latin-1 subset of Unicode.
isControl :: Char -> Bool

-- | Selects Unicode symbol characters, including mathematical and currency
--   symbols.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>MathSymbol</a></li>
--   <li><a>CurrencySymbol</a></li>
--   <li><a>ModifierSymbol</a></li>
--   <li><a>OtherSymbol</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Symbol".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isSymbol 'a'
--   False
--   
--   &gt;&gt;&gt; isSymbol '6'
--   False
--   
--   &gt;&gt;&gt; isSymbol '='
--   True
--   </pre>
--   
--   The definition of "math symbol" may be a little counter-intuitive
--   depending on one's background:
--   
--   <pre>
--   &gt;&gt;&gt; isSymbol '+'
--   True
--   
--   &gt;&gt;&gt; isSymbol '-'
--   False
--   </pre>
isSymbol :: Char -> Bool

-- | Selects Unicode punctuation characters, including various kinds of
--   connectors, brackets and quotes.
--   
--   This function returns <a>True</a> if its argument has one of the
--   following <a>GeneralCategory</a>s, or <a>False</a> otherwise:
--   
--   <ul>
--   <li><a>ConnectorPunctuation</a></li>
--   <li><a>DashPunctuation</a></li>
--   <li><a>OpenPunctuation</a></li>
--   <li><a>ClosePunctuation</a></li>
--   <li><a>InitialQuote</a></li>
--   <li><a>FinalQuote</a></li>
--   <li><a>OtherPunctuation</a></li>
--   </ul>
--   
--   These classes are defined in the <a>Unicode Character Database</a>,
--   part of the Unicode standard. The same document defines what is and is
--   not a "Punctuation".
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isPunctuation 'a'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '7'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '♥'
--   False
--   
--   &gt;&gt;&gt; isPunctuation '"'
--   True
--   
--   &gt;&gt;&gt; isPunctuation '?'
--   True
--   
--   &gt;&gt;&gt; isPunctuation '—'
--   True
--   </pre>
isPunctuation :: Char -> Bool

-- | Selects ASCII hexadecimal digits, i.e. <tt>'0'</tt>..<tt>'9'</tt>,
--   <tt>'a'</tt>..<tt>'f'</tt>, <tt>'A'</tt>..<tt>'F'</tt>.
isHexDigit :: Char -> Bool

-- | Selects ASCII octal digits, i.e. <tt>'0'</tt>..<tt>'7'</tt>.
isOctDigit :: Char -> Bool

-- | Selects ASCII upper-case letters, i.e. characters satisfying both
--   <a>isAscii</a> and <a>isUpper</a>.
isAsciiUpper :: Char -> Bool

-- | Selects ASCII lower-case letters, i.e. characters satisfying both
--   <a>isAscii</a> and <a>isLower</a>.
isAsciiLower :: Char -> Bool

-- | Selects the first 256 characters of the Unicode character set,
--   corresponding to the ISO 8859-1 (Latin-1) character set.
isLatin1 :: Char -> Bool

-- | Selects the first 128 characters of the Unicode character set,
--   corresponding to the ASCII character set.
isAscii :: Char -> Bool

-- | The Unicode general category of the character. This relies on the
--   <a>Enum</a> instance of <a>GeneralCategory</a>, which must remain in
--   the same order as the categories are presented in the Unicode
--   standard.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; generalCategory 'a'
--   LowercaseLetter
--   
--   &gt;&gt;&gt; generalCategory 'A'
--   UppercaseLetter
--   
--   &gt;&gt;&gt; generalCategory '0'
--   DecimalNumber
--   
--   &gt;&gt;&gt; generalCategory '%'
--   OtherPunctuation
--   
--   &gt;&gt;&gt; generalCategory '♥'
--   OtherSymbol
--   
--   &gt;&gt;&gt; generalCategory '\31'
--   Control
--   
--   &gt;&gt;&gt; generalCategory ' '
--   Space
--   </pre>
generalCategory :: Char -> GeneralCategory

-- | Unicode General Categories (column 2 of the UnicodeData table) in the
--   order they are listed in the Unicode standard (the Unicode Character
--   Database, in particular).
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; :t OtherLetter
--   OtherLetter :: GeneralCategory
--   </pre>
--   
--   <a>Eq</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; UppercaseLetter == UppercaseLetter
--   True
--   
--   &gt;&gt;&gt; UppercaseLetter == LowercaseLetter
--   False
--   </pre>
--   
--   <a>Ord</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; NonSpacingMark &lt;= MathSymbol
--   True
--   </pre>
--   
--   <a>Enum</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; enumFromTo ModifierLetter SpacingCombiningMark
--   [ModifierLetter,OtherLetter,NonSpacingMark,SpacingCombiningMark]
--   </pre>
--   
--   <tt>Read</tt> instance:
--   
--   <pre>
--   &gt;&gt;&gt; read "DashPunctuation" :: GeneralCategory
--   DashPunctuation
--   
--   &gt;&gt;&gt; read "17" :: GeneralCategory
--   *** Exception: Prelude.read: no parse
--   </pre>
--   
--   <a>Show</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; show EnclosingMark
--   "EnclosingMark"
--   </pre>
--   
--   <a>Bounded</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; minBound :: GeneralCategory
--   UppercaseLetter
--   
--   &gt;&gt;&gt; maxBound :: GeneralCategory
--   NotAssigned
--   </pre>
--   
--   <a>Ix</a> instance:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Ix ( index )
--   
--   &gt;&gt;&gt; index (OtherLetter,Control) FinalQuote
--   12
--   
--   &gt;&gt;&gt; index (OtherLetter,Control) Format
--   *** Exception: Error in array index
--   </pre>
data GeneralCategory

-- | Lu: Letter, Uppercase
UppercaseLetter :: GeneralCategory

-- | Ll: Letter, Lowercase
LowercaseLetter :: GeneralCategory

-- | Lt: Letter, Titlecase
TitlecaseLetter :: GeneralCategory

-- | Lm: Letter, Modifier
ModifierLetter :: GeneralCategory

-- | Lo: Letter, Other
OtherLetter :: GeneralCategory

-- | Mn: Mark, Non-Spacing
NonSpacingMark :: GeneralCategory

-- | Mc: Mark, Spacing Combining
SpacingCombiningMark :: GeneralCategory

-- | Me: Mark, Enclosing
EnclosingMark :: GeneralCategory

-- | Nd: Number, Decimal
DecimalNumber :: GeneralCategory

-- | Nl: Number, Letter
LetterNumber :: GeneralCategory

-- | No: Number, Other
OtherNumber :: GeneralCategory

-- | Pc: Punctuation, Connector
ConnectorPunctuation :: GeneralCategory

-- | Pd: Punctuation, Dash
DashPunctuation :: GeneralCategory

-- | Ps: Punctuation, Open
OpenPunctuation :: GeneralCategory

-- | Pe: Punctuation, Close
ClosePunctuation :: GeneralCategory

-- | Pi: Punctuation, Initial quote
InitialQuote :: GeneralCategory

-- | Pf: Punctuation, Final quote
FinalQuote :: GeneralCategory

-- | Po: Punctuation, Other
OtherPunctuation :: GeneralCategory

-- | Sm: Symbol, Math
MathSymbol :: GeneralCategory

-- | Sc: Symbol, Currency
CurrencySymbol :: GeneralCategory

-- | Sk: Symbol, Modifier
ModifierSymbol :: GeneralCategory

-- | So: Symbol, Other
OtherSymbol :: GeneralCategory

-- | Zs: Separator, Space
Space :: GeneralCategory

-- | Zl: Separator, Line
LineSeparator :: GeneralCategory

-- | Zp: Separator, Paragraph
ParagraphSeparator :: GeneralCategory

-- | Cc: Other, Control
Control :: GeneralCategory

-- | Cf: Other, Format
Format :: GeneralCategory

-- | Cs: Other, Surrogate
Surrogate :: GeneralCategory

-- | Co: Other, Private Use
PrivateUse :: GeneralCategory

-- | Cn: Other, Not Assigned
NotAssigned :: GeneralCategory

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: () => a -> (a -> b) -> b
infixl 1 &

-- | <tt><a>on</a> b u x y</tt> runs the binary function <tt>b</tt>
--   <i>on</i> the results of applying unary function <tt>u</tt> to two
--   arguments <tt>x</tt> and <tt>y</tt>. From the opposite perspective, it
--   transforms two inputs and combines the outputs.
--   
--   <pre>
--   ((+) `<a>on</a>` f) x y = f x + f y
--   </pre>
--   
--   Typical usage: <tt><a>sortBy</a> (<tt>compare</tt> `on`
--   <tt>fst</tt>)</tt>.
--   
--   Algebraic properties:
--   
--   <ul>
--   <li><pre>(*) `on` <a>id</a> = (*) -- (if (*) ∉ {⊥, <a>const</a>
--   ⊥})</pre></li>
--   <li><pre>((*) `on` f) `on` g = (*) `on` (f . g)</pre></li>
--   <li><pre><a>flip</a> on f . <a>flip</a> on g = <a>flip</a> on (g .
--   f)</pre></li>
--   </ul>
on :: () => (b -> b -> c) -> (a -> b) -> a -> a -> c
infixl 0 `on`

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with a
--   constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with a constant <tt>String</tt>, resulting in an
--   <tt><tt>Either</tt> <tt>Int</tt> <tt>String</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | Convert an <a>Int</a> in the range <tt>0</tt>..<tt>15</tt> to the
--   corresponding single digit <a>Char</a>. This function fails on other
--   inputs, and generates lower-case hexadecimal digits.
intToDigit :: Int -> Char

-- | Convert a character to a string using only printable characters, using
--   Haskell source-language escape conventions. For example:
--   
--   <pre>
--   showLitChar '\n' s  =  "\\n" ++ s
--   </pre>
showLitChar :: Char -> ShowS

-- | 'iterate\'' is the strict version of <a>iterate</a>.
--   
--   It ensures that the result of each application of force to weak head
--   normal form before proceeding.
iterate' :: () => (a -> a) -> a -> [a]

-- | A strictly accumulating version of <a>scanl</a>
scanl' :: () => (b -> a -> b) -> b -> [a] -> [b]

-- | A strict version of <a>foldl1</a>
foldl1' :: () => (a -> a -> a) -> [a] -> a

-- | Decompose a list into its head and tail. If the list is empty, returns
--   <a>Nothing</a>. If the list is non-empty, returns <tt><a>Just</a> (x,
--   xs)</tt>, where <tt>x</tt> is the head of the list and <tt>xs</tt> its
--   tail.
uncons :: () => [a] -> Maybe (a, [a])

-- | The <a>fromJust</a> function extracts the element out of a <a>Just</a>
--   and throws an error if its argument is <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromJust (Just 1)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust (Just 10))
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 2 * (fromJust Nothing)
--   *** Exception: Maybe.fromJust: Nothing
--   </pre>
fromJust :: () => Maybe a -> a

-- | Swap the components of a pair.
swap :: () => (a, b) -> (b, a)

-- | Non-empty (and non-strict) list type.
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|

-- | This is a valid definition of <a>stimes</a> for an idempotent
--   <a>Monoid</a>.
--   
--   When <tt>mappend x x = x</tt>, this definition should be preferred,
--   because it works in <i>O(1)</i> rather than <i>O(log n)</i>
stimesIdempotentMonoid :: (Integral b, Monoid a) => b -> a -> a

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
newtype StateT s (m :: Type -> Type) a
StateT :: (s -> m (a, s)) -> StateT s a
[runStateT] :: StateT s a -> s -> m (a, s)

-- | A monad transformer that adds exceptions to other monads.
--   
--   <tt>ExceptT</tt> constructs a monad parameterized over two things:
--   
--   <ul>
--   <li>e - The exception type.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function yields a computation that produces the
--   given value, while <tt>&gt;&gt;=</tt> sequences two subcomputations,
--   exiting on the first exception.
newtype ExceptT e (m :: Type -> Type) a
ExceptT :: m (Either e a) -> ExceptT e a

-- | Class of monads which can perform primitive state-transformer actions
class Monad m => PrimMonad (m :: Type -> Type) where {
    
    -- | State token type
    type family PrimState (m :: Type -> Type) :: Type;
}

-- | Execute a primitive operation
primitive :: PrimMonad m => (State# (PrimState m) -> (# State# (PrimState m), a #)) -> m a

-- | The class of monad transformers. Instances should satisfy the
--   following laws, which state that <a>lift</a> is a monad
--   transformation:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
class MonadTrans (t :: Type -> Type -> Type -> Type)

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a

-- | A map of integers to values <tt>a</tt>.
data IntMap a

-- | The <tt>nubIntOn</tt> function behaves just like <a>nubInt</a> except
--   it performs comparisons not on the original datatype, but a
--   user-specified projection from that datatype.
--   
--   <h4>Strictness</h4>
--   
--   <tt>nubIntOn</tt> is strict in the values of the function applied to
--   the elements of the list.
nubIntOn :: () => (a -> Int) -> [a] -> [a]

-- | &lt;math&gt;. The <tt>nubInt</tt> function removes duplicate
--   <a>Int</a> values from a list. In particular, it keeps only the first
--   occurrence of each element. By using an <a>IntSet</a> internally, it
--   attains better asymptotics than the standard <a>nub</a> function.
--   
--   See also <a>nubIntOn</a>, a more widely applicable generalization.
--   
--   <h4>Strictness</h4>
--   
--   <tt>nubInt</tt> is strict in the elements of the list.
nubInt :: [Int] -> [Int]

-- | The <tt>nubOrdOn</tt> function behaves just like <a>nubOrd</a> except
--   it performs comparisons not on the original datatype, but a
--   user-specified projection from that datatype.
--   
--   <h4>Strictness</h4>
--   
--   <tt>nubOrdOn</tt> is strict in the values of the function applied to
--   the elements of the list.
nubOrdOn :: Ord b => (a -> b) -> [a] -> [a]

-- | &lt;math&gt;. The <tt>nubOrd</tt> function removes duplicate elements
--   from a list. In particular, it keeps only the first occurrence of each
--   element. By using a <a>Set</a> internally it has better asymptotics
--   than the standard <a>nub</a> function.
--   
--   <h4>Strictness</h4>
--   
--   <tt>nubOrd</tt> is strict in the elements of the list.
--   
--   <h4>Efficiency note</h4>
--   
--   When applicable, it is almost always better to use <a>nubInt</a> or
--   <a>nubIntOn</a> instead of this function. For example, the best way to
--   nub a list of characters is
--   
--   <pre>
--   nubIntOn fromEnum xs
--   </pre>
nubOrd :: Ord a => [a] -> [a]

-- | A set of integers.
data IntSet

-- | This is a length of time, as measured by a clock. Conversion functions
--   will treat it as seconds. It has a precision of 10^-12 s.
data DiffTime

-- | Lift the standard <a>rnf</a> function through the type constructor.
rnf2 :: (NFData2 p, NFData a, NFData b) => p a b -> ()

-- | Lift the standard <a>rnf</a> function through the type constructor.
rnf1 :: (NFData1 f, NFData a) => f a -> ()

-- | Reduce to weak head normal form
--   
--   Equivalent to <tt>\x -&gt; <a>seq</a> x ()</tt>.
--   
--   Useful for defining <a>NFData</a> for types for which NF=WHNF holds.
--   
--   <pre>
--   data T = C1 | C2 | C3
--   instance NFData T where rnf = rwhnf
--   </pre>
rwhnf :: () => a -> ()

-- | Deeply strict version of <a>&lt;$&gt;</a>.
(<$!!>) :: (Monad m, NFData b) => (a -> b) -> m a -> m b
infixl 4 <$!!>

-- | a variant of <a>deepseq</a> that is useful in some circumstances:
--   
--   <pre>
--   force x = x `deepseq` x
--   </pre>
--   
--   <tt>force x</tt> fully evaluates <tt>x</tt>, and then returns it. Note
--   that <tt>force x</tt> only performs evaluation when the value of
--   <tt>force x</tt> itself is demanded, so essentially it turns shallow
--   evaluation into deep evaluation.
--   
--   <a>force</a> can be conveniently used in combination with
--   <tt>ViewPatterns</tt>:
--   
--   <pre>
--   {-# LANGUAGE BangPatterns, ViewPatterns #-}
--   import Control.DeepSeq
--   
--   someFun :: ComplexData -&gt; SomeResult
--   someFun (force -&gt; !arg) = {- 'arg' will be fully evaluated -}
--   </pre>
--   
--   Another useful application is to combine <a>force</a> with
--   <a>evaluate</a> in order to force deep evaluation relative to other
--   <a>IO</a> operations:
--   
--   <pre>
--   import Control.Exception (evaluate)
--   import Control.DeepSeq
--   
--   main = do
--     result &lt;- evaluate $ force $ pureComputation
--     {- 'result' will be fully evaluated at this point -}
--     return ()
--   </pre>
--   
--   Finally, here's an exception safe variant of the <tt>readFile'</tt>
--   example:
--   
--   <pre>
--   readFile' :: FilePath -&gt; IO String
--   readFile' fn = bracket (openFile fn ReadMode) hClose $ \h -&gt;
--                          evaluate . force =&lt;&lt; hGetContents h
--   </pre>
force :: NFData a => a -> a

-- | the deep analogue of <a>$!</a>. In the expression <tt>f $!! x</tt>,
--   <tt>x</tt> is fully evaluated before the function <tt>f</tt> is
--   applied to it.
($!!) :: NFData a => (a -> b) -> a -> b
infixr 0 $!!

-- | <a>deepseq</a>: fully evaluates the first argument, before returning
--   the second.
--   
--   The name <a>deepseq</a> is used to illustrate the relationship to
--   <a>seq</a>: where <a>seq</a> is shallow in the sense that it only
--   evaluates the top level of its argument, <a>deepseq</a> traverses the
--   entire data structure evaluating it completely.
--   
--   <a>deepseq</a> can be useful for forcing pending exceptions,
--   eradicating space leaks, or forcing lazy I/O to happen. It is also
--   useful in conjunction with parallel Strategies (see the
--   <tt>parallel</tt> package).
--   
--   There is no guarantee about the ordering of evaluation. The
--   implementation may evaluate the components of the structure in any
--   order or in parallel. To impose an actual order on evaluation, use
--   <tt>pseq</tt> from <a>Control.Parallel</a> in the <tt>parallel</tt>
--   package.
deepseq :: NFData a => a -> b -> b

-- | A class of functors that can be fully evaluated.
class NFData1 (f :: Type -> Type)

-- | <a>liftRnf</a> should reduce its argument to normal form (that is,
--   fully evaluate all sub-components), given an argument to reduce
--   <tt>a</tt> arguments, and then return '()'.
--   
--   See <a>rnf</a> for the generic deriving.
liftRnf :: NFData1 f => (a -> ()) -> f a -> ()

-- | A class of bifunctors that can be fully evaluated.
class NFData2 (p :: Type -> Type -> Type)

-- | <a>liftRnf2</a> should reduce its argument to normal form (that is,
--   fully evaluate all sub-components), given functions to reduce
--   <tt>a</tt> and <tt>b</tt> arguments respectively, and then return
--   '()'.
--   
--   <b>Note</b>: Unlike for the unary <a>liftRnf</a>, there is currently
--   no support for generically deriving <a>liftRnf2</a>.
liftRnf2 :: NFData2 p => (a -> ()) -> (b -> ()) -> p a b -> ()

-- | Generate a list of length <tt>n</tt> of all elements of
--   <tt><a>Finite</a> n</tt>.
finites :: KnownNat n => [Finite n]

-- | Convert an <a>Integer</a> into a <a>Finite</a>, returning
--   <a>Nothing</a> if the input is out of bounds.
packFinite :: KnownNat n => Integer -> Maybe (Finite n)

-- | Convert a <a>Finite</a> into the corresponding <a>Integer</a>.
getFinite :: () => Finite n -> Integer

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>MonadError</a> class. (If you are using the deprecated
--   <a>Control.Monad.Error</a> or <a>Control.Monad.Trans.Error</a>, you
--   may also have to define an <a>Error</a> instance.)
class Monad m => MonadError e (m :: Type -> Type) | m -> e

-- | Is used within a monadic computation to begin exception processing.
throwError :: MonadError e m => e -> m a

-- | A handler function to handle previous errors and return to normal
--   execution. A common idiom is:
--   
--   <pre>
--   do { action1; action2; action3 } `catchError` handler
--   </pre>
--   
--   where the <tt>action</tt> functions can call <a>throwError</a>. Note
--   that <tt>handler</tt> and the do-block must have the same return type.
catchError :: MonadError e m => m a -> (e -> m a) -> m a

-- | Formally, the class <a>Profunctor</a> represents a profunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where the first argument is
--   contravariant and the second argument is covariant.
--   
--   You can define a <a>Profunctor</a> by either defining <a>dimap</a> or
--   by defining both <a>lmap</a> and <a>rmap</a>.
--   
--   If you supply <a>dimap</a>, you should ensure that:
--   
--   <pre>
--   <a>dimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>lmap</a> and <a>rmap</a>, ensure:
--   
--   <pre>
--   <a>lmap</a> <a>id</a> ≡ <a>id</a>
--   <a>rmap</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>dimap</a> f g ≡ <a>lmap</a> f <a>.</a> <a>rmap</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>dimap</a> (f <a>.</a> g) (h <a>.</a> i) ≡ <a>dimap</a> g h <a>.</a> <a>dimap</a> f i
--   <a>lmap</a> (f <a>.</a> g) ≡ <a>lmap</a> g <a>.</a> <a>lmap</a> f
--   <a>rmap</a> (f <a>.</a> g) ≡ <a>rmap</a> f <a>.</a> <a>rmap</a> g
--   </pre>
class Profunctor (p :: Type -> Type -> Type)

-- | Map over both arguments at the same time.
--   
--   <pre>
--   <a>dimap</a> f g ≡ <a>lmap</a> f <a>.</a> <a>rmap</a> g
--   </pre>
dimap :: Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d

-- | Map the first argument contravariantly.
--   
--   <pre>
--   <a>lmap</a> f ≡ <a>dimap</a> f <a>id</a>
--   </pre>
lmap :: Profunctor p => (a -> b) -> p b c -> p a c

-- | Map the second argument covariantly.
--   
--   <pre>
--   <a>rmap</a> ≡ <a>dimap</a> <a>id</a>
--   </pre>
rmap :: Profunctor p => (b -> c) -> p a b -> p a c

-- | Unwrap a state monad computation as a function. (The inverse of
--   <a>state</a>.)
runState :: () => State s a -> s -> (a, s)

-- | A state monad parameterized by the type <tt>s</tt> of the state to
--   carry.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
type State s = StateT s Identity

-- | Gets specific component of the state, using a projection function
--   supplied.
gets :: MonadState s m => (s -> a) -> m a

-- | View the value pointed to by a <a>Getter</a>, <a>Iso</a> or
--   <a>Lens</a> or the result of folding over all the results of a
--   <a>Fold</a> or <a>Traversal</a> that points at a monoidal value.
--   
--   <pre>
--   <a>view</a> <a>.</a> <a>to</a> ≡ <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (to f) a
--   f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view _2 (1,"hello")
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (to succ) 5
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (_2._1) ("hello",("world","!!!"))
--   "world"
--   </pre>
--   
--   As <a>view</a> is commonly used to access the target of a
--   <a>Getter</a> or obtain a monoidal summary of the targets of a
--   <a>Fold</a>, It may be useful to think of it as having one of these
--   more restricted signatures:
--   
--   <pre>
--   <a>view</a> ::             <a>Getter</a> s a     -&gt; s -&gt; a
--   <a>view</a> :: <a>Monoid</a> m =&gt; <a>Fold</a> s m       -&gt; s -&gt; m
--   <a>view</a> ::             <a>Iso'</a> s a       -&gt; s -&gt; a
--   <a>view</a> ::             <a>Lens'</a> s a      -&gt; s -&gt; a
--   <a>view</a> :: <a>Monoid</a> m =&gt; <a>Traversal'</a> s m -&gt; s -&gt; m
--   </pre>
--   
--   In a more general setting, such as when working with a <a>Monad</a>
--   transformer stack you can use:
--   
--   <pre>
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Getter</a> s a     -&gt; m a
--   <a>view</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> a) =&gt; <a>Fold</a> s a       -&gt; m a
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Iso'</a> s a       -&gt; m a
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Lens'</a> s a      -&gt; m a
--   <a>view</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; m a
--   </pre>
view :: MonadReader s m => Getting a s a -> m a

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a constant value.
--   
--   <pre>
--   (<a>&lt;$</a>) ≡ <a>set</a> <a>mapped</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set _2 "hello" (1,())
--   (1,"hello")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set mapped () [1,2,3,4]
--   [(),(),(),()]
--   </pre>
--   
--   Note: Attempting to <a>set</a> a <a>Fold</a> or <a>Getter</a> will
--   fail at compile time with an relatively nice error message.
--   
--   <pre>
--   <a>set</a> :: <a>Setter</a> s t a b    -&gt; b -&gt; s -&gt; t
--   <a>set</a> :: <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; t
--   <a>set</a> :: <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; t
--   <a>set</a> :: <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; t
--   </pre>
set :: () => ASetter s t a b -> b -> s -> t

-- | Modify the target of a <a>Lens</a> or all the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a function.
--   
--   <pre>
--   <a>fmap</a> ≡ <a>over</a> <a>mapped</a>
--   <a>fmapDefault</a> ≡ <a>over</a> <a>traverse</a>
--   <a>sets</a> <a>.</a> <a>over</a> ≡ <a>id</a>
--   <a>over</a> <a>.</a> <a>sets</a> ≡ <a>id</a>
--   </pre>
--   
--   Given any valid <a>Setter</a> <tt>l</tt>, you can also rely on the
--   law:
--   
--   <pre>
--   <a>over</a> l f <a>.</a> <a>over</a> l g = <a>over</a> l (f <a>.</a> g)
--   </pre>
--   
--   <i>e.g.</i>
--   
--   <pre>
--   &gt;&gt;&gt; over mapped f (over mapped g [a,b,c]) == over mapped (f . g) [a,b,c]
--   True
--   </pre>
--   
--   Another way to view <a>over</a> is to say that it transforms a
--   <a>Setter</a> into a "semantic editor combinator".
--   
--   <pre>
--   &gt;&gt;&gt; over mapped f (Just a)
--   Just (f a)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over mapped (*10) [1,2,3]
--   [10,20,30]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _1 f (a,b)
--   (f a,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _1 show (10,20)
--   ("10",20)
--   </pre>
--   
--   <pre>
--   <a>over</a> :: <a>Setter</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
--   <a>over</a> :: <a>ASetter</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
--   </pre>
over :: () => ASetter s t a b -> (a -> b) -> s -> t

-- | A 0-dimensional vector
--   
--   <pre>
--   &gt;&gt;&gt; pure 1 :: V0 Int
--   V0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V0 + V0
--   V0
--   </pre>
data V0 a
V0 :: V0 a

-- | A 4-dimensional vector.
data V4 a
V4 :: !a -> !a -> !a -> !a -> V4 a

-- | A space that distinguishes orthogonal basis vectors <a>_x</a>,
--   <a>_y</a>, <a>_z</a>, <a>_w</a>. (It may have more.)
class R3 t => R4 (t :: Type -> Type)

-- | <pre>
--   &gt;&gt;&gt; V4 1 2 3 4 ^._w
--   4
--   </pre>
_w :: R4 t => Lens' (t a) a
_xyzw :: R4 t => Lens' (t a) (V4 a)

-- | A 3-dimensional vector
data V3 a
V3 :: !a -> !a -> !a -> V3 a

-- | A space that distinguishes 3 orthogonal basis vectors: <a>_x</a>,
--   <a>_y</a>, and <a>_z</a>. (It may have more)
class R2 t => R3 (t :: Type -> Type)

-- | <pre>
--   &gt;&gt;&gt; V3 1 2 3 ^. _z
--   3
--   </pre>
_z :: R3 t => Lens' (t a) a
_xyz :: R3 t => Lens' (t a) (V3 a)

-- | A 2-dimensional vector
--   
--   <pre>
--   &gt;&gt;&gt; pure 1 :: V2 Int
--   V2 1 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 + V2 3 4
--   V2 4 6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 * V2 3 4
--   V2 3 8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum (V2 1 2)
--   3
--   </pre>
data V2 a
V2 :: !a -> !a -> V2 a

-- | A space that distinguishes 2 orthogonal basis vectors <a>_x</a> and
--   <a>_y</a>, but may have more.
class R1 t => R2 (t :: Type -> Type)

-- | <pre>
--   &gt;&gt;&gt; V2 1 2 ^._y
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 &amp; _y .~ 3
--   V2 1 3
--   </pre>
_y :: R2 t => Lens' (t a) a
_xy :: R2 t => Lens' (t a) (V2 a)

-- | A 1-dimensional vector
--   
--   <pre>
--   &gt;&gt;&gt; pure 1 :: V1 Int
--   V1 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V1 2 + V1 3
--   V1 5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V1 2 * V1 3
--   V1 6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum (V1 2)
--   2
--   </pre>
newtype V1 a
V1 :: a -> V1 a

-- | A space that has at least 1 basis vector <a>_x</a>.
class R1 (t :: Type -> Type)

-- | <pre>
--   &gt;&gt;&gt; V1 2 ^._x
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V1 2 &amp; _x .~ 3
--   V1 3
--   </pre>
_x :: R1 t => Lens' (t a) a

-- | A variant of <a>modify</a> in which the computation is strict in the
--   new state.
modify' :: MonadState s m => (s -> s) -> m ()

-- | Monadic state transformer.
--   
--   Maps an old state to a new state inside a state monad. The old state
--   is thrown away.
--   
--   <pre>
--   Main&gt; :t modify ((+1) :: Int -&gt; Int)
--   modify (...) :: (MonadState Int a) =&gt; a ()
--   </pre>
--   
--   This says that <tt>modify (+1)</tt> acts over any Monad that is a
--   member of the <tt>MonadState</tt> class, with an <tt>Int</tt> state.
modify :: MonadState s m => (s -> s) -> m ()

-- | The parameterizable exception monad.
--   
--   Computations are either exceptions or normal values.
--   
--   The <a>return</a> function returns a normal value, while
--   <tt>&gt;&gt;=</tt> exits on the first exception. For a variant that
--   continues after an error and collects all the errors, see
--   <a>Errors</a>.
type Except e = ExceptT e Identity

-- | Extractor for computations in the exception monad. (The inverse of
--   <a>except</a>).
runExcept :: () => Except e a -> Either e a

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExcept</a> (<a>mapExcept</a> f m) = f (<a>runExcept</a>
--   m)</pre></li>
--   </ul>
mapExcept :: () => (Either e a -> Either e' b) -> Except e a -> Except e' b

-- | Transform any exceptions thrown by the computation using the given
--   function (a specialization of <a>withExceptT</a>).
withExcept :: () => (e -> e') -> Except e a -> Except e' a

-- | The inverse of <a>ExceptT</a>.
runExceptT :: () => ExceptT e m a -> m (Either e a)

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExceptT</a> (<a>mapExceptT</a> f m) = f
--   (<a>runExceptT</a> m)</pre></li>
--   </ul>
mapExceptT :: () => (m (Either e a) -> n (Either e' b)) -> ExceptT e m a -> ExceptT e' n b

-- | Transform any exceptions thrown by the computation using the given
--   function.
withExceptT :: Functor m => (e -> e') -> ExceptT e m a -> ExceptT e' m a

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalState</a> m s = <a>fst</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
evalState :: () => State s a -> s -> a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execState</a> m s = <a>snd</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
execState :: () => State s a -> s -> s

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runState</a> (<a>mapState</a> f m) = f . <a>runState</a>
--   m</pre></li>
--   </ul>
mapState :: () => ((a, s) -> (b, s)) -> State s a -> State s b

-- | <tt><a>withState</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withState</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withState :: () => (s -> s) -> State s a -> State s a

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalStateT</a> m s = <a>liftM</a> <a>fst</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
evalStateT :: Monad m => StateT s m a -> s -> m a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execStateT</a> m s = <a>liftM</a> <a>snd</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
execStateT :: Monad m => StateT s m a -> s -> m s

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runStateT</a> (<a>mapStateT</a> f m) = f .
--   <a>runStateT</a> m</pre></li>
--   </ul>
mapStateT :: () => (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b

-- | <tt><a>withStateT</a> f m</tt> executes action <tt>m</tt> on a state
--   modified by applying <tt>f</tt>.
--   
--   <ul>
--   <li><pre><a>withStateT</a> f m = <a>modify</a> f &gt;&gt; m</pre></li>
--   </ul>
withStateT :: () => (s -> s) -> StateT s m a -> StateT s m a
class Foldable t => Foldable1 (t :: Type -> Type)
fold1 :: (Foldable1 t, Semigroup m) => t m -> m
foldMap1 :: (Foldable1 t, Semigroup m) => (a -> m) -> t a -> m
toNonEmpty :: Foldable1 t => t a -> NonEmpty a

-- | A non-empty (by construction) set of values <tt>a</tt>. At least one
--   value exists in an <tt><a>NESet</a> a</tt> at all times.
--   
--   Functions that <i>take</i> an <a>NESet</a> can safely operate on it
--   with the assumption that it has at least one item.
--   
--   Functions that <i>return</i> an <a>NESet</a> provide an assurance that
--   the result has at least one item.
--   
--   <a>Data.Set.NonEmpty</a> re-exports the API of <a>Data.Set</a>,
--   faithfully reproducing asymptotics, typeclass constraints, and
--   semantics. Functions that ensure that input and output sets are both
--   non-empty (like <a>insert</a>) return <a>NESet</a>, but functions that
--   might potentially return an empty map (like <a>delete</a>) return a
--   <a>Set</a> instead.
--   
--   You can directly construct an <a>NESet</a> with the API from
--   <a>Data.Set.NonEmpty</a>; it's more or less the same as constructing a
--   normal <a>Set</a>, except you don't have access to <a>empty</a>. There
--   are also a few ways to construct an <a>NESet</a> from a <a>Set</a>:
--   
--   <ol>
--   <li>The <a>nonEmptySet</a> smart constructor will convert a
--   <tt><a>Set</a> a</tt> into a <tt><a>Maybe</a> (<a>NESet</a> a)</tt>,
--   returning <a>Nothing</a> if the original <a>Set</a> was empty.</li>
--   <li>You can use the <a>insertSet</a> family of functions to insert a
--   value into a <a>Set</a> to create a guaranteed <a>NESet</a>.</li>
--   <li>You can use the <a>IsNonEmpty</a> and <a>IsEmpty</a> patterns to
--   "pattern match" on a <a>Set</a> to reveal it as either containing a
--   <a>NESet</a> or an empty map.</li>
--   <li><a>withNonEmpty</a> offers a continuation-based interface for
--   deconstructing a <a>Set</a> and treating it as if it were an
--   <a>NESet</a>.</li>
--   </ol>
--   
--   You can convert an <a>NESet</a> into a <a>Set</a> with <a>toSet</a> or
--   <a>IsNonEmpty</a>, essentially "obscuring" the non-empty property from
--   the type.
data NESet a

-- | A non-empty (by construction) map from keys <tt>k</tt> to values
--   <tt>a</tt>. At least one key-value pair exists in an <tt><a>NEMap</a>
--   k v</tt> at all times.
--   
--   Functions that <i>take</i> an <a>NEMap</a> can safely operate on it
--   with the assumption that it has at least one key-value pair.
--   
--   Functions that <i>return</i> an <a>NEMap</a> provide an assurance that
--   the result has at least one key-value pair.
--   
--   <a>Data.Map.NonEmpty</a> re-exports the API of <a>Data.Map</a>,
--   faithfully reproducing asymptotics, typeclass constraints, and
--   semantics. Functions that ensure that input and output maps are both
--   non-empty (like <a>insert</a>) return <a>NEMap</a>, but functions that
--   might potentially return an empty map (like <a>delete</a>) return a
--   <a>Map</a> instead.
--   
--   You can directly construct an <a>NEMap</a> with the API from
--   <a>Data.Map.NonEmpty</a>; it's more or less the same as constructing a
--   normal <a>Map</a>, except you don't have access to <a>empty</a>. There
--   are also a few ways to construct an <a>NEMap</a> from a <a>Map</a>:
--   
--   <ol>
--   <li>The <a>nonEmptyMap</a> smart constructor will convert a
--   <tt><a>Map</a> k a</tt> into a <tt><a>Maybe</a> (<a>NEMap</a> k
--   a)</tt>, returning <a>Nothing</a> if the original <a>Map</a> was
--   empty.</li>
--   <li>You can use the <a>insertMap</a> family of functions to insert a
--   value into a <a>Map</a> to create a guaranteed <a>NEMap</a>.</li>
--   <li>You can use the <a>IsNonEmpty</a> and <a>IsEmpty</a> patterns to
--   "pattern match" on a <a>Map</a> to reveal it as either containing a
--   <a>NEMap</a> or an empty map.</li>
--   <li><a>withNonEmpty</a> offers a continuation-based interface for
--   deconstructing a <a>Map</a> and treating it as if it were an
--   <a>NEMap</a>.</li>
--   </ol>
--   
--   You can convert an <a>NEMap</a> into a <a>Map</a> with <a>toMap</a> or
--   <a>IsNonEmpty</a>, essentially "obscuring" the non-empty property from
--   the type.
data NEMap k a

-- | The implementation of the pointed list structure which tracks the
--   current position in the list structure.
data PointedList a

-- | Create an action to force a value; generalizes <a>evaluate</a>
evalPrim :: PrimMonad m => a -> m a
touch :: PrimMonad m => a -> m ()
unsafeInlineST :: () => ST s a -> a
unsafeInlineIO :: () => IO a -> a
unsafeInlinePrim :: PrimBase m => m a -> a

-- | Convert an <a>IO</a> action to any <a>PrimMonad</a>. This operation is
--   highly unsafe!
unsafeIOToPrim :: PrimMonad m => IO a -> m a

-- | Convert an <a>ST</a> action with an arbitraty state token to any
--   <a>PrimMonad</a>. This operation is highly unsafe!
unsafeSTToPrim :: PrimMonad m => ST s a -> m a

-- | Convert any <a>PrimBase</a> to <a>IO</a>. This operation is highly
--   unsafe!
unsafePrimToIO :: PrimBase m => m a -> IO a

-- | Convert any <a>PrimBase</a> to <a>ST</a> with an arbitrary state
--   token. This operation is highly unsafe!
unsafePrimToST :: PrimBase m => m a -> ST s a

-- | Convert a <a>PrimBase</a> to another monad with a possibly different
--   state token. This operation is highly unsafe!
unsafePrimToPrim :: (PrimBase m1, PrimMonad m2) => m1 a -> m2 a

-- | Convert an <a>ST</a> action to a <a>PrimMonad</a>.
stToPrim :: PrimMonad m => ST (PrimState m) a -> m a

-- | Convert an <a>IO</a> action to a <a>PrimMonad</a>.
ioToPrim :: (PrimMonad m, PrimState m ~ RealWorld) => IO a -> m a

-- | Convert a <a>PrimBase</a> to <a>ST</a>
primToST :: PrimBase m => m a -> ST (PrimState m) a

-- | Convert a <a>PrimBase</a> with a <a>RealWorld</a> state token to
--   <a>IO</a>
primToIO :: (PrimBase m, PrimState m ~ RealWorld) => m a -> IO a

-- | Convert a <a>PrimBase</a> to another monad with the same state token.
primToPrim :: (PrimBase m1, PrimMonad m2, PrimState m1 ~ PrimState m2) => m1 a -> m2 a

-- | Lifts a <a>PrimBase</a> into another <a>PrimMonad</a> with the same
--   underlying state token type.
liftPrim :: (PrimBase m1, PrimMonad m2, PrimState m1 ~ PrimState m2) => m1 a -> m2 a

-- | Execute a primitive operation with no result
primitive_ :: PrimMonad m => (State# (PrimState m) -> State# (PrimState m)) -> m ()

-- | Class of primitive monads for state-transformer actions.
--   
--   Unlike <a>PrimMonad</a>, this typeclass requires that the
--   <tt>Monad</tt> be fully expressed as a state transformer, therefore
--   disallowing other monad transformers on top of the base <tt>IO</tt> or
--   <tt>ST</tt>.
class PrimMonad m => PrimBase (m :: Type -> Type)

-- | Expose the internal structure of the monad
internal :: PrimBase m => m a -> State# (PrimState m) -> (# State# (PrimState m), a #)

-- | Monadic fold over the elements of a non-empty structure, associating
--   to the left, i.e. from left to right.
--   
--   <pre>
--   let g = flip $ (=&lt;&lt;) . f
--   in foldlM1 f (x1 :| [x2, ..., xn]) == (...((x1 `f` x2) `g` x2) `g`...) `g` xn
--   </pre>
foldlM1 :: (Foldable1 t, Monad m) => (a -> a -> m a) -> t a -> m a

-- | Monadic fold over the elements of a non-empty structure, associating
--   to the right, i.e. from right to left.
--   
--   <pre>
--   let g = (=&lt;&lt;) . f
--   in foldrM1 f (x1 :| [x2, ..., xn]) == x1 `g` (x2 `g` ... (xn-1 `f` xn)...)
--   </pre>
foldrM1 :: (Foldable1 t, Monad m) => (a -> a -> m a) -> t a -> m a
asum1 :: (Foldable1 t, Alt m) => t (m a) -> m a

-- | Usable default for foldMap, but only if you define foldMap1 yourself
foldMapDefault1 :: (Foldable1 t, Monoid m) => (a -> m) -> t a -> m
sequenceA1_ :: (Foldable1 t, Apply f) => t (f a) -> f ()
for1_ :: (Foldable1 t, Apply f) => t a -> (a -> f b) -> f ()
traverse1_ :: (Foldable1 t, Apply f) => (a -> f b) -> t a -> f ()

-- | Insert <tt>m</tt> between each pair of <tt>m</tt> derived from
--   <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; intercalateMap1 " " show $ True :| [False, True]
--   "True False True"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalateMap1 " " show $ True :| []
--   "True"
--   </pre>
intercalateMap1 :: (Foldable1 t, Semigroup m) => m -> (a -> m) -> t a -> m

-- | Insert an <tt>m</tt> between each pair of 't m'. Equivalent to
--   <a>intercalateMap1</a> with <a>id</a> as the second argument.
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 ", " $ "hello" :| ["how", "are", "you"]
--   "hello, how, are, you"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 ", " $ "hello" :| []
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 mempty $ "I" :| ["Am", "Fine", "You?"]
--   "IAmFineYou?"
--   </pre>
intercalate1 :: (Foldable1 t, Semigroup m) => m -> t m -> m

-- | Substitute various time-related information for each %-code in the
--   string, as per <a>formatCharacter</a>.
--   
--   The general form is
--   <tt>%&lt;modifier&gt;&lt;width&gt;&lt;specifier&gt;</tt>, where
--   <tt>&lt;modifier&gt;</tt> and <tt>&lt;width&gt;</tt> are optional.
--   
--   <h2><tt>&lt;modifier&gt;</tt></h2>
--   
--   glibc-style modifiers can be used before the specifier (here marked as
--   <tt>z</tt>):
--   
--   <ul>
--   <li><i><tt>%-z</tt></i> no padding</li>
--   <li><i><tt>%_z</tt></i> pad with spaces</li>
--   <li><i><tt>%0z</tt></i> pad with zeros</li>
--   <li><i><tt>%^z</tt></i> convert to upper case</li>
--   <li><i><tt>%#z</tt></i> convert to lower case (consistently, unlike
--   glibc)</li>
--   </ul>
--   
--   <h2><tt>&lt;width&gt;</tt></h2>
--   
--   Width digits can also be used after any modifiers and before the
--   specifier (here marked as <tt>z</tt>), for example:
--   
--   <ul>
--   <li><i><tt>%4z</tt></i> pad to 4 characters (with default padding
--   character)</li>
--   <li><i><tt>%_12z</tt></i> pad with spaces to 12 characters</li>
--   </ul>
--   
--   <h2><tt>&lt;specifier&gt;</tt></h2>
--   
--   For all types (note these three are done by <a>formatTime</a>, not by
--   <a>formatCharacter</a>):
--   
--   <ul>
--   <li><i><tt>%%</tt></i> <tt>%</tt></li>
--   <li><i><tt>%t</tt></i> tab</li>
--   <li><i><tt>%n</tt></i> newline</li>
--   </ul>
--   
--   <h3><a>TimeZone</a></h3>
--   
--   For <a>TimeZone</a> (and <a>ZonedTime</a> and <a>UTCTime</a>):
--   
--   <ul>
--   <li><i><tt>%z</tt></i> timezone offset in the format
--   <tt>-HHMM</tt>.</li>
--   <li><i><tt>%Z</tt></i> timezone name</li>
--   </ul>
--   
--   <h3><a>LocalTime</a></h3>
--   
--   For <a>LocalTime</a> (and <a>ZonedTime</a> and <a>UTCTime</a> and
--   <a>UniversalTime</a>):
--   
--   <ul>
--   <li><i><tt>%c</tt></i> as <a>dateTimeFmt</a> <tt>locale</tt> (e.g.
--   <tt>%a %b %e %H:%M:%S %Z %Y</tt>)</li>
--   </ul>
--   
--   <h3><a>TimeOfDay</a></h3>
--   
--   For <a>TimeOfDay</a> (and <a>LocalTime</a> and <a>ZonedTime</a> and
--   <a>UTCTime</a> and <a>UniversalTime</a>):
--   
--   <ul>
--   <li><i><tt>%R</tt></i> same as <tt>%H:%M</tt></li>
--   <li><i><tt>%T</tt></i> same as <tt>%H:%M:%S</tt></li>
--   <li><i><tt>%X</tt></i> as <a>timeFmt</a> <tt>locale</tt> (e.g.
--   <tt>%H:%M:%S</tt>)</li>
--   <li><i><tt>%r</tt></i> as <a>time12Fmt</a> <tt>locale</tt> (e.g.
--   <tt>%I:%M:%S %p</tt>)</li>
--   <li><i><tt>%P</tt></i> day-half of day from (<a>amPm</a>
--   <tt>locale</tt>), converted to lowercase, <tt>am</tt>,
--   <tt>pm</tt></li>
--   <li><i><tt>%p</tt></i> day-half of day from (<a>amPm</a>
--   <tt>locale</tt>), <tt>AM</tt>, <tt>PM</tt></li>
--   <li><i><tt>%H</tt></i> hour of day (24-hour), 0-padded to two chars,
--   <tt>00</tt> - <tt>23</tt></li>
--   <li><i><tt>%k</tt></i> hour of day (24-hour), space-padded to two
--   chars, <tt> 0</tt> - <tt>23</tt></li>
--   <li><i><tt>%I</tt></i> hour of day-half (12-hour), 0-padded to two
--   chars, <tt>01</tt> - <tt>12</tt></li>
--   <li><i><tt>%l</tt></i> hour of day-half (12-hour), space-padded to two
--   chars, <tt> 1</tt> - <tt>12</tt></li>
--   <li><i><tt>%M</tt></i> minute of hour, 0-padded to two chars,
--   <tt>00</tt> - <tt>59</tt></li>
--   <li><i><tt>%S</tt></i> second of minute (without decimal part),
--   0-padded to two chars, <tt>00</tt> - <tt>60</tt></li>
--   <li><i><tt>%q</tt></i> picosecond of second, 0-padded to twelve chars,
--   <tt>000000000000</tt> - <tt>999999999999</tt>.</li>
--   <li><i><tt>%Q</tt></i> decimal point and fraction of second, up to 12
--   second decimals, without trailing zeros. For a whole number of
--   seconds, <tt>%Q</tt> omits the decimal point unless padding is
--   specified.</li>
--   </ul>
--   
--   <h3><a>UTCTime</a> and <a>ZonedTime</a></h3>
--   
--   For <a>UTCTime</a> and <a>ZonedTime</a>:
--   
--   <ul>
--   <li><i><tt>%s</tt></i> number of whole seconds since the Unix epoch.
--   For times before the Unix epoch, this is a negative number. Note that
--   in <tt>%s.%q</tt> and <tt>%s%Q</tt> the decimals are positive, not
--   negative. For example, 0.9 seconds before the Unix epoch is formatted
--   as <tt>-1.1</tt> with <tt>%s%Q</tt>.</li>
--   </ul>
--   
--   <h3><a>Day</a></h3>
--   
--   For <a>Day</a> (and <a>LocalTime</a> and <a>ZonedTime</a> and
--   <a>UTCTime</a> and <a>UniversalTime</a>):
--   
--   <ul>
--   <li><i><tt>%D</tt></i> same as <tt>%m/%d/%y</tt></li>
--   <li><i><tt>%F</tt></i> same as <tt>%Y-%m-%d</tt></li>
--   <li><i><tt>%x</tt></i> as <a>dateFmt</a> <tt>locale</tt> (e.g.
--   <tt>%m/%d/%y</tt>)</li>
--   <li><i><tt>%Y</tt></i> year, no padding. Note <tt>%0Y</tt> and
--   <tt>%_Y</tt> pad to four chars</li>
--   <li><i><tt>%y</tt></i> year of century, 0-padded to two chars,
--   <tt>00</tt> - <tt>99</tt></li>
--   <li><i><tt>%C</tt></i> century, no padding. Note <tt>%0C</tt> and
--   <tt>%_C</tt> pad to two chars</li>
--   <li><i><tt>%B</tt></i> month name, long form (<a>fst</a> from
--   <a>months</a> <tt>locale</tt>), <tt>January</tt> -
--   <tt>December</tt></li>
--   <li><i><tt>%b</tt>, <tt>%h</tt></i> month name, short form (<a>snd</a>
--   from <a>months</a> <tt>locale</tt>), <tt>Jan</tt> - <tt>Dec</tt></li>
--   <li><i><tt>%m</tt></i> month of year, 0-padded to two chars,
--   <tt>01</tt> - <tt>12</tt></li>
--   <li><i><tt>%d</tt></i> day of month, 0-padded to two chars,
--   <tt>01</tt> - <tt>31</tt></li>
--   <li><i><tt>%e</tt></i> day of month, space-padded to two chars, <tt>
--   1</tt> - <tt>31</tt></li>
--   <li><i><tt>%j</tt></i> day of year, 0-padded to three chars,
--   <tt>001</tt> - <tt>366</tt></li>
--   <li><i><tt>%f</tt></i> century for Week Date format, no padding. Note
--   <tt>%0f</tt> and <tt>%_f</tt> pad to two chars</li>
--   <li><i><tt>%V</tt></i> week of year for Week Date format, 0-padded to
--   two chars, <tt>01</tt> - <tt>53</tt></li>
--   <li><i><tt>%u</tt></i> day of week for Week Date format, <tt>1</tt> -
--   <tt>7</tt></li>
--   <li><i><tt>%a</tt></i> day of week, short form (<a>snd</a> from
--   <a>wDays</a> <tt>locale</tt>), <tt>Sun</tt> - <tt>Sat</tt></li>
--   <li><i><tt>%A</tt></i> day of week, long form (<a>fst</a> from
--   <a>wDays</a> <tt>locale</tt>), <tt>Sunday</tt> -
--   <tt>Saturday</tt></li>
--   <li><i><tt>%U</tt></i> week of year where weeks start on Sunday (as
--   <a>sundayStartWeek</a>), 0-padded to two chars, <tt>00</tt> -
--   <tt>53</tt></li>
--   <li><i><tt>%w</tt></i> day of week number, <tt>0</tt> (= Sunday) -
--   <tt>6</tt> (= Saturday)</li>
--   <li><i><tt>%W</tt></i> week of year where weeks start on Monday (as
--   <a>mondayStartWeek</a>), 0-padded to two chars, <tt>00</tt> -
--   <tt>53</tt></li>
--   </ul>
formatTime :: FormatTime t => TimeLocale -> String -> t -> String
type NumericPadOption = Maybe Char
class FormatTime t
formatCharacter :: FormatTime t => Char -> Maybe (TimeLocale -> Maybe NumericPadOption -> Maybe Int -> t -> String)
readsTime :: ParseTime t => TimeLocale -> String -> ReadS t
readTime :: ParseTime t => TimeLocale -> String -> String -> t
parseTime :: ParseTime t => TimeLocale -> String -> String -> Maybe t

-- | Parse a time value given a format string. See <a>parseTimeM</a> for
--   details.
readPTime :: ParseTime t => Bool -> TimeLocale -> String -> ReadP t

-- | Parse a time value given a format string. See <a>parseTimeM</a> for
--   details.
readSTime :: ParseTime t => Bool -> TimeLocale -> String -> ReadS t

-- | Parse a time value given a format string. Fails if the input could not
--   be parsed using the given format. See <a>parseTimeM</a> for details.
parseTimeOrError :: ParseTime t => Bool -> TimeLocale -> String -> String -> t

-- | Parses a time value given a format string. Supports the same %-codes
--   as <tt>formatTime</tt>, including <tt>%-</tt>, <tt>%_</tt> and
--   <tt>%0</tt> modifiers, however padding widths are not supported. Case
--   is not significant in the input string. Some variations in the input
--   are accepted:
--   
--   <ul>
--   <li><i><tt>%z</tt></i> accepts any of <tt>-HHMM</tt> or
--   <tt>-HH:MM</tt>.</li>
--   <li><i><tt>%Z</tt></i> accepts any string of letters, or any of the
--   formats accepted by <tt>%z</tt>.</li>
--   <li><i><tt>%0Y</tt></i> accepts exactly four digits.</li>
--   <li><i><tt>%0G</tt></i> accepts exactly four digits.</li>
--   <li><i><tt>%0C</tt></i> accepts exactly two digits.</li>
--   <li><i><tt>%0f</tt></i> accepts exactly two digits.</li>
--   </ul>
parseTimeM :: (Monad m, ParseTime t) => Bool -> TimeLocale -> String -> String -> m t

-- | The class of types which can be parsed given a UNIX-style time format
--   string.
class ParseTime t

-- | Builds a time value from a parsed input string. If the input does not
--   include all the information needed to construct a complete value, any
--   missing parts should be taken from 1970-01-01 00:00:00 +0000 (which
--   was a Thursday). In the absence of <tt>%C</tt> or <tt>%Y</tt>, century
--   is 1969 - 2068.
buildTime :: ParseTime t => TimeLocale -> [(Char, String)] -> Maybe t

utcToLocalZonedTime :: UTCTime -> IO ZonedTime
getZonedTime :: IO ZonedTime
zonedTimeToUTC :: ZonedTime -> UTCTime
utcToZonedTime :: TimeZone -> UTCTime -> ZonedTime

-- | A local time together with a time zone.
data ZonedTime
ZonedTime :: LocalTime -> TimeZone -> ZonedTime
[zonedTimeToLocalTime] :: ZonedTime -> LocalTime
[zonedTimeZone] :: ZonedTime -> TimeZone

-- | Format string according to <a>RFC822</a>.
rfc822DateFormat :: String

-- | Construct format string according to <a>ISO-8601</a>.
--   
--   The <tt>Maybe String</tt> argument allows to supply an optional time
--   specification. E.g.:
--   
--   <pre>
--   <a>iso8601DateFormat</a> Nothing            == "%Y-%m-%d"           -- i.e. <tt><i>YYYY-MM-DD</i></tt>
--   <a>iso8601DateFormat</a> (Just "%H:%M:%S")  == "%Y-%m-%dT%H:%M:%S"  -- i.e. <tt><i>YYYY-MM-DD</i>T<i>HH:MM:SS</i></tt>
--   </pre>
iso8601DateFormat :: Maybe String -> String

-- | Locale representing American usage.
--   
--   <a>knownTimeZones</a> contains only the ten time-zones mentioned in
--   RFC 822 sec. 5: "UT", "GMT", "EST", "EDT", "CST", "CDT", "MST", "MDT",
--   "PST", "PDT". Note that the parsing functions will regardless parse
--   single-letter military time-zones and +HHMM format.
defaultTimeLocale :: TimeLocale
data TimeLocale
TimeLocale :: [(String, String)] -> [(String, String)] -> (String, String) -> String -> String -> String -> String -> [TimeZone] -> TimeLocale

-- | full and abbreviated week days, starting with Sunday
[wDays] :: TimeLocale -> [(String, String)]

-- | full and abbreviated months
[months] :: TimeLocale -> [(String, String)]

-- | AM/PM symbols
[amPm] :: TimeLocale -> (String, String)

-- | formatting strings
[dateTimeFmt] :: TimeLocale -> String

-- | formatting strings
[dateFmt] :: TimeLocale -> String

-- | formatting strings
[timeFmt] :: TimeLocale -> String

-- | formatting strings
[time12Fmt] :: TimeLocale -> String

-- | time zones known by name
[knownTimeZones] :: TimeLocale -> [TimeZone]

-- | Get the UT1 time of a local time on a particular meridian (in degrees,
--   positive is East).
localTimeToUT1 :: Rational -> LocalTime -> UniversalTime

-- | Get the local time of a UT1 time on a particular meridian (in degrees,
--   positive is East).
ut1ToLocalTime :: Rational -> UniversalTime -> LocalTime

-- | Get the UTC time of a local time in a time zone.
localTimeToUTC :: TimeZone -> LocalTime -> UTCTime

-- | Get the local time of a UTC time in a time zone.
utcToLocalTime :: TimeZone -> UTCTime -> LocalTime

-- | A simple day and time aggregate, where the day is of the specified
--   parameter, and the time is a TimeOfDay. Conversion of this (as local
--   civil time) to UTC depends on the time zone. Conversion of this (as
--   local mean time) to UT1 depends on the longitude.
data LocalTime
LocalTime :: Day -> TimeOfDay -> LocalTime
[localDay] :: LocalTime -> Day
[localTimeOfDay] :: LocalTime -> TimeOfDay

-- | Get the fraction of a day since midnight given a time of day.
timeOfDayToDayFraction :: TimeOfDay -> Rational

-- | Get the time of day given the fraction of a day since midnight.
dayFractionToTimeOfDay :: Rational -> TimeOfDay

-- | Get the time since midnight for a given time of day.
timeOfDayToTime :: TimeOfDay -> DiffTime

-- | Get the time of day given a time since midnight. Time more than 24h
--   will be converted to leap-seconds.
timeToTimeOfDay :: DiffTime -> TimeOfDay

-- | Convert a time of day in some timezone to a time of day in UTC,
--   together with a day adjustment.
localToUTCTimeOfDay :: TimeZone -> TimeOfDay -> (Integer, TimeOfDay)

-- | Convert a time of day in UTC to a time of day in some timezone,
--   together with a day adjustment.
utcToLocalTimeOfDay :: TimeZone -> TimeOfDay -> (Integer, TimeOfDay)
makeTimeOfDayValid :: Int -> Int -> Pico -> Maybe TimeOfDay

-- | Hour twelve
midday :: TimeOfDay

-- | Hour zero
midnight :: TimeOfDay

-- | Time of day as represented in hour, minute and second (with
--   picoseconds), typically used to express local time of day.
data TimeOfDay
TimeOfDay :: Int -> Int -> Pico -> TimeOfDay

-- | range 0 - 23
[todHour] :: TimeOfDay -> Int

-- | range 0 - 59
[todMin] :: TimeOfDay -> Int

-- | Note that 0 &lt;= <a>todSec</a> &lt; 61, accomodating leap seconds.
--   Any local minute may have a leap second, since leap seconds happen in
--   all zones simultaneously
[todSec] :: TimeOfDay -> Pico

-- | Get the current time-zone.
getCurrentTimeZone :: IO TimeZone

-- | Get the local time-zone for a given time (varying as per summertime
--   adjustments).
getTimeZone :: UTCTime -> IO TimeZone

-- | The UTC time zone.
utc :: TimeZone

-- | Text representing the offset of this timezone, such as "-0800" or
--   "+0400" (like <tt>%z</tt> in formatTime).
timeZoneOffsetString :: TimeZone -> String

-- | Text representing the offset of this timezone, such as "-0800" or
--   "+0400" (like <tt>%z</tt> in formatTime), with arbitrary padding.
timeZoneOffsetString' :: Maybe Char -> TimeZone -> String

-- | Create a nameless non-summer timezone for this number of hours.
hoursToTimeZone :: Int -> TimeZone

-- | Create a nameless non-summer timezone for this number of minutes.
minutesToTimeZone :: Int -> TimeZone

-- | A TimeZone is a whole number of minutes offset from UTC, together with
--   a name and a "just for summer" flag.
data TimeZone
TimeZone :: Int -> Bool -> String -> TimeZone

-- | The number of minutes offset from UTC. Positive means local time will
--   be later in the day than UTC.
[timeZoneMinutes] :: TimeZone -> Int

-- | Is this time zone just persisting for the summer?
[timeZoneSummerOnly] :: TimeZone -> Bool

-- | The name of the zone, typically a three- or four-letter acronym.
[timeZoneName] :: TimeZone -> String

-- | diffUTCTime a b = a - b
diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime

-- | addUTCTime a b = a + b
addUTCTime :: NominalDiffTime -> UTCTime -> UTCTime

-- | Get the current <a>UTCTime</a> from the system clock.
getCurrentTime :: IO UTCTime

-- | The Modified Julian Date is the day with the fraction of the day,
--   measured from UT midnight. It's used to represent UT1, which is time
--   as measured by the earth's rotation, adjusted for various wobbles.
newtype UniversalTime
ModJulianDate :: Rational -> UniversalTime
[getModJulianDate] :: UniversalTime -> Rational

-- | The resolution of <a>getSystemTime</a>, <tt>getCurrentTime</tt>,
--   <tt>getPOSIXTime</tt>
getTime_resolution :: DiffTime

-- | One day in <a>NominalDiffTime</a>.
nominalDay :: NominalDiffTime

-- | This is a length of time, as measured by UTC. Conversion functions
--   will treat it as seconds. It has a precision of 10^-12 s. It ignores
--   leap-seconds, so it's not necessarily a fixed amount of clock time.
--   For instance, 23:00 UTC + 2 hours of NominalDiffTime = 01:00 UTC (+ 1
--   day), regardless of whether a leap-second intervened.
data NominalDiffTime

-- | Get the number of picoseconds in a <a>DiffTime</a>.
diffTimeToPicoseconds :: DiffTime -> Integer

-- | Create a <a>DiffTime</a> from a number of picoseconds.
picosecondsToDiffTime :: Integer -> DiffTime

-- | Create a <a>DiffTime</a> which represents an integral number of
--   seconds.
secondsToDiffTime :: Integer -> DiffTime

-- | Add years, matching month and day, with Feb 29th rolled over to Mar
--   1st if necessary. For instance, 2004-02-29 + 2 years = 2006-03-01.
addGregorianYearsRollOver :: Integer -> Day -> Day

-- | Add years, matching month and day, with Feb 29th clipped to Feb 28th
--   if necessary. For instance, 2004-02-29 + 2 years = 2006-02-28.
addGregorianYearsClip :: Integer -> Day -> Day

-- | Add months, with days past the last day of the month rolling over to
--   the next month. For instance, 2005-01-30 + 1 month = 2005-03-02.
addGregorianMonthsRollOver :: Integer -> Day -> Day

-- | Add months, with days past the last day of the month clipped to the
--   last day. For instance, 2005-01-30 + 1 month = 2005-02-28.
addGregorianMonthsClip :: Integer -> Day -> Day

-- | The number of days in a given month according to the proleptic
--   Gregorian calendar. First argument is year, second is month.
gregorianMonthLength :: Integer -> Int -> Int

-- | Show in ISO 8601 format (yyyy-mm-dd)
showGregorian :: Day -> String

-- | Convert from proleptic Gregorian calendar. First argument is year,
--   second month number (1-12), third day (1-31). Invalid values will
--   return Nothing
fromGregorianValid :: Integer -> Int -> Int -> Maybe Day

-- | Convert from proleptic Gregorian calendar. First argument is year,
--   second month number (1-12), third day (1-31). Invalid values will be
--   clipped to the correct range, month first, then day.
fromGregorian :: Integer -> Int -> Int -> Day

-- | Convert to proleptic Gregorian calendar. First element of result is
--   year, second month number (1-12), third day (1-31).
toGregorian :: Day -> (Integer, Int, Int)

-- | Is this year a leap year according to the proleptic Gregorian
--   calendar?
isLeapYear :: Integer -> Bool
diffDays :: Day -> Day -> Integer
addDays :: Integer -> Day -> Day

-- | The Modified Julian Day is a standard count of days, with zero being
--   the day 1858-11-17.
newtype Day
ModifiedJulianDay :: Integer -> Day
[toModifiedJulianDay] :: Day -> Integer

-- | Removes duplicate elements from a list, keeping only the first
--   occurrence. This is usually faster than <a>ordNub</a>, especially for
--   things that have a slow comparison (like <a>String</a>).
hashNub :: (Witherable t, Eq a, Hashable a) => t a -> t a

-- | Removes duplicate elements from a list, keeping only the first
--   occurrence. This is asymptotically faster than using <a>nub</a> from
--   <a>Data.List</a>.
ordNub :: (Witherable t, Ord a) => t a -> t a

-- | Remove the duplicate elements through a filter. It is often faster
--   than <a>ordNubOf</a>, especially when the comparison is expensive.
hashNubOf :: (Eq a, Hashable a) => FilterLike' (State (HashSet a)) s a -> s -> s

-- | Remove the duplicate elements through a filter.
ordNubOf :: Ord a => FilterLike' (State (Set a)) s a -> s -> s

-- | <pre>
--   <a>forMaybe</a> = <a>flip</a> <a>wither</a>
--   </pre>
forMaybe :: (Witherable t, Applicative f) => t a -> (a -> f (Maybe b)) -> f (t b)

-- | Filter each element of a structure targeted by a <a>Filter</a>.
filterOf :: () => FilterLike' Identity s a -> (a -> Bool) -> s -> s

-- | <a>filterA</a> through a filter.
filterAOf :: Functor f => FilterLike' f s a -> (a -> f Bool) -> s -> f s

-- | <a>catMaybes</a> through a filter.
catMaybesOf :: () => FilterLike Identity s t (Maybe a) a -> s -> t

-- | <a>mapMaybe</a> through a filter.
mapMaybeOf :: () => FilterLike Identity s t a b -> (a -> Maybe b) -> s -> t

-- | <pre>
--   <a>forMaybeOf</a> ≡ <a>flip</a>
--   </pre>
forMaybeOf :: () => FilterLike f s t a b -> s -> (a -> f (Maybe b)) -> f t

-- | <a>witherOf</a> is actually <a>id</a>, but left for consistency.
witherOf :: () => FilterLike f s t a b -> (a -> f (Maybe b)) -> s -> f t

-- | Reconstitute a <a>Filter</a> from its monomorphic form.
cloneFilter :: () => FilterLike (Peat a b) s t a b -> Filter s t a b

-- | This type allows combinators to take a <a>Filter</a> specializing the
--   parameter <tt>f</tt>.
type FilterLike (f :: Type -> Type) s t a b = a -> f Maybe b -> s -> f t

-- | A <a>Filter</a> is like a <a>Traversal</a>, but you can also remove
--   targets.
type Filter s t a b = forall (f :: Type -> Type). Applicative f => FilterLike f s t a b

-- | A simple <a>FilterLike</a>.
type FilterLike' (f :: Type -> Type) s a = FilterLike f s s a a

-- | A simple <a>Filter</a>.
type Filter' s a = forall (f :: Type -> Type). Applicative f => FilterLike' f s a

-- | This is used to characterize and clone a <a>Filter</a>. Since
--   <tt>FilterLike (Peat a b) s t a b</tt> is monomorphic, it can be used
--   to store a filter in a container.
newtype Peat a b t
Peat :: (forall (f :: Type -> Type). Applicative f => (a -> f (Maybe b)) -> f t) -> Peat a b t
[runPeat] :: Peat a b t -> forall (f :: Type -> Type). Applicative f => (a -> f (Maybe b)) -> f t

-- | Like <a>Functor</a>, but it include <a>Maybe</a> effects.
--   
--   Formally, the class <a>Filterable</a> represents a functor from
--   <tt>Kleisli Maybe</tt> to <tt>Hask</tt>.
--   
--   A definition of <a>mapMaybe</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>identity</i></i> <tt><a>mapMaybe</a> Just ≡ id</tt></li>
--   <li><i><i>conservation</i></i> <tt><a>mapMaybe</a> (Just . f) ≡
--   <a>fmap</a> f</tt></li>
--   <li><i><i>composition</i></i> <tt><a>mapMaybe</a> f . <a>mapMaybe</a>
--   g ≡ <a>mapMaybe</a> (f &lt;=&lt; g)</tt></li>
--   </ul>
class Functor f => Filterable (f :: Type -> Type)

-- | Like <a>mapMaybe</a>.
mapMaybe :: Filterable f => (a -> Maybe b) -> f a -> f b

-- | <pre>
--   <a>catMaybes</a> ≡ <a>mapMaybe</a> <a>id</a>
--   </pre>
catMaybes :: Filterable f => f (Maybe a) -> f a

-- | Like <a>Traversable</a>, but you can remove elements instead of
--   updating them.
--   
--   A definition of <a>wither</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>identity</i></i> <tt><a>wither</a> (<a>pure</a> . Just) ≡
--   <a>pure</a></tt></li>
--   <li><i><i>conservation</i></i> <tt><a>wither</a> (<a>fmap</a>
--   <a>Just</a> . f) ≡ <a>traverse</a> f</tt></li>
--   <li><i><i>composition</i></i> <tt><a>Compose</a> . <a>fmap</a>
--   (<a>wither</a> f) . <a>wither</a> g ≡ <a>wither</a> (<a>Compose</a> .
--   <a>fmap</a> (<a>wither</a> f) . g)</tt></li>
--   </ul>
--   
--   Parametricity implies the naturality law:
--   
--   <pre>
--   t . <a>wither</a> f ≡ <a>wither</a> (t . f)
--   </pre>
class (Traversable t, Filterable t) => Witherable (t :: Type -> Type)

-- | <pre>
--   <a>traverse</a> f ≡ <a>wither</a> (<a>fmap</a> <a>Just</a> . f)
--   </pre>
wither :: (Witherable t, Applicative f) => (a -> f (Maybe b)) -> t a -> f (t b)

-- | <pre>
--   Monadic variant of <a>wither</a>. This may have more efficient implementation.
--   </pre>
witherM :: (Witherable t, Monad m) => (a -> m (Maybe b)) -> t a -> m (t b)

-- | <pre>
--   <a>Compose</a> . <a>fmap</a> (<a>filterA</a> f) . <a>filterA</a> g ≡ <a>filterA</a> (x -&gt; <a>Compose</a> $ <a>fmap</a> (b -&gt; (b&amp;&amp;) <a>$</a> f x) (g x)
--   </pre>
filterA :: (Witherable t, Applicative f) => (a -> f Bool) -> t a -> f (t a)

-- | Strip trailing and leading whitespace.
strip :: String -> String

-- | Convert an <a>Either</a> into a <a>Maybe</a>, or any
--   <a>Alternative</a> instance, forgetting the error value.
eitherToMaybe :: Alternative m => Either e a -> m a

-- | Convert a <a>Maybe</a> into an <a>Either</a>, or any <a>MonadError</a>
--   instance, by providing an error value in case <a>Nothing</a> was
--   given.
maybeToEither :: MonadError e m => e -> Maybe a -> m a

-- | Like <a>find</a>, but instead of taking an <tt>a -&gt; Bool</tt>,
--   takes an <tt>a -&gt; Maybe b</tt> and returns the first success.
findMaybe :: Foldable t => (a -> Maybe b) -> t a -> Maybe b

-- | Strict (!!)
(!!!) :: [a] -> Int -> a

-- | Iterate until a <a>Nothing</a> is produced
iterateMaybe :: (a -> Maybe a) -> a -> [a]

-- | A tuple of the same item twice
dup :: a -> (a, a)

-- | <a>scanl</a> generalized to all <a>Traversable</a>.
scanlT :: Traversable t => (b -> a -> b) -> b -> t a -> t b

-- | <a>scanr</a> generalized to all <a>Traversable</a>.
scanrT :: Traversable t => (a -> b -> b) -> b -> t a -> t b

-- | Lazily find the first repeated item.
firstRepeated :: Ord a => [a] -> Maybe a

-- | Build a frequency map
freqs :: (Foldable f, Ord a) => f a -> Map a Int

-- | Collect all possible single-item perturbations from a given perturbing
--   function.
--   
--   <pre>
--   perturbations (\i -&gt; [i - 1, i + 1]) [0,10,100]
--   </pre>
--   
--   <h2>[ [-1,10,100]</h2>
--   
--   , [ 1,10,100] , [ 0, 9,100] , [ 0,11,100] , [ 0,10, 99] , [ 0,10,101]
--   ]
perturbations :: (a -> [a]) -> [a] -> [[a]]

-- | Clear out characters not matching a predicate
clearOut :: (Char -> Bool) -> String -> String

-- | Get the key-value pair corresponding to the maximum value in the map
maximumVal :: Ord b => Map a b -> Maybe (a, b)

-- | Get the key-value pair corresponding to the maximum value in the map,
--   with a custom comparing function.
--   
--   <pre>
--   'maximumVal' == 'maximumValBy' 'compare'
--   </pre>
maximumValBy :: (b -> b -> Ordering) -> Map a b -> Maybe (a, b)

-- | Get the key-value pair corresponding to the minimum value in the map,
--   with a custom comparing function.
--   
--   <pre>
--   'minimumVal' == 'minimumValBy' 'compare'
--   </pre>
minimumValBy :: (b -> b -> Ordering) -> Map a b -> Maybe (a, b)

-- | Get the key-value pair corresponding to the minimum value in the map
minimumVal :: Ord b => Map a b -> Maybe (a, b)

-- | Version of <a>maximumValBy</a> for nonempty maps.
maximumValByNE :: (b -> b -> Ordering) -> NEMap a b -> (a, b)

-- | Version of <a>maximumVal</a> for nonempty maps.
maximumValNE :: Ord b => NEMap a b -> (a, b)

-- | Version of <a>minimumValBy</a> for nonempty maps.
minimumValByNE :: (b -> b -> Ordering) -> NEMap a b -> (a, b)

-- | Version of <a>minimumVal</a> for nonempty maps.
minimumValNE :: Ord b => NEMap a b -> (a, b)

-- | Delete a potential value from a <a>Finite</a>.
deleteFinite :: KnownNat n => Finite (n + 1) -> Finite (n + 1) -> Maybe (Finite n)

-- | <a>foldMap</a>, but in parallel.
foldMapPar :: Monoid b => (a -> b) -> [a] -> b

-- | <tt>foldMap1</tt>, but in parallel.
foldMapPar1 :: Semigroup b => (a -> b) -> NonEmpty a -> b

-- | <a>Fold</a> for computing mean and variance
meanVar :: Fractional a => Fold a (a, a)

-- | Errors that might happen when running a <a>:~&gt;</a> on some input.
data SolutionError
SEParse :: SolutionError
SESolve :: SolutionError

-- | Wrap an <tt>a <a>:~&gt;</a> b</tt> and hide the type variables so we
--   can put different solutions in a container.
data SomeSolution
[MkSomeSol] :: (a :~> b) -> SomeSolution

-- | Abstracting over the type of a challenge solver to help with cleaner
--   solutions.
--   
--   A <tt>a <a>:~&gt;</a> b</tt> encapsulates something that solves a
--   challenge with input type <tt>a</tt> into a response of type
--   <tt>b</tt>.
--   
--   Consists of a parser, a shower, and a solver. The solver solves a
--   general <tt>a -&gt; <a>Maybe</a> b</tt> function, and the parser and
--   shower are used to handle the boilerplate of parsing and printing the
--   solution.
data a :~> b
MkSol :: (String -> Maybe a) -> (?dyno :: DynoMap => a -> Maybe b) -> (b -> String) -> (:~>) a b

-- | parse input into an <tt>a</tt>
[sParse] :: (:~>) a b -> String -> Maybe a

-- | solve an <tt>a</tt> input to a <tt>b</tt> solution
[sSolve] :: (:~>) a b -> ?dyno :: DynoMap => a -> Maybe b

-- | print out the <tt>b</tt> solution in a pretty way
[sShow] :: (:~>) a b -> b -> String

-- | Construct a <a>:~&gt;</a> from just a normal <tt>String -&gt;
--   String</tt> solver. Does no parsing or special printing treatment.
withSolver' :: (String -> String) -> String :~> String

-- | Construct a <a>:~&gt;</a> from a <tt>String -&gt; <a>Maybe</a>
--   String</tt> solver, which might fail. Does no parsing or special
--   printing treatment.
withSolver :: (String -> Maybe String) -> String :~> String

-- | Run a <a>:~&gt;</a> on some input.
runSolution :: (a :~> b) -> String -> Either SolutionError String

-- | Run a <a>:~&gt;</a> on some input, with a map of dynamic values for
--   testing
runSolutionWith :: Map String Dynamic -> (a :~> b) -> String -> Either SolutionError String

-- | Run a <a>SomeSolution</a> on some input.
runSomeSolution :: SomeSolution -> String -> Either SolutionError String

-- | Run a <a>SomeSolution</a> on some input, with a map of dynamic values
--   for testing
runSomeSolutionWith :: Map String Dynamic -> SomeSolution -> String -> Either SolutionError String

-- | From a <tt>?dyno</tt> Implicit Params, look up a value at a given key.
--   Meant to be used with TypeApplications:
--   
--   <pre>
--   'dyno' @"hello"
--   </pre>
--   
--   This can be used within the body of <a>sSolve</a>, since it will
--   always be called with the implicit parameter.
--   
--   When called on actual puzzle input, result will always be
--   <a>Nothing</a>. But, for some test inputs, there might be supplied
--   values.
--   
--   This is useful for when some problems have parameters that are
--   different with test inputs than for actual inputs.
dyno :: forall a. (Typeable a, ?dyno :: DynoMap) => String -> Maybe a

-- | A version of <a>dyno</a> taking a default value in case the key is not
--   in the map. When called on actual puzzle input, this is always
--   <a>id</a>. However, for some test inputs, there might be supplied
--   values.
--   
--   Meant to be used with TypeApplications:
--   
--   <pre>
--   'dyno_' @"hello" 7
--   </pre>
--   
--   This is useful for when some problems have parameters that are
--   different with test inputs than for actual inputs.
dyno_ :: forall a. (Typeable a, ?dyno :: DynoMap) => String -> a -> a


-- | Day 25. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day25


-- | Day 24. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day24


-- | Day 23. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day23


-- | Day 22. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day22


-- | Day 21. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day21


-- | Day 20. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day20


-- | Day 19. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day19


-- | Day 18. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day18


-- | Day 17. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day17


-- | Day 16. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day16


-- | Day 15. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day15


-- | Day 14. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day14


-- | Day 13. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
--   
--   <ul>
--   <li>Replace <a>AOC.Prelude</a> imports to specific modules (with
--   explicit imports) for readability.</li>
--   <li>Remove the <tt>-Wno-unused-imports</tt> and
--   <tt>-Wno-unused-top-binds</tt> pragmas.</li>
--   <li>Replace the partial type signatures underscores in the solution
--   types <tt>_ :~&gt; _</tt> with the actual types of inputs and outputs
--   of the solution. You can delete the type signatures completely and GHC
--   will recommend what should go in place of the underscores.</li>
--   </ul>
module AOC.Challenge.Day13


-- | Day 11. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day11
day11a :: Int :~> Point
day11b :: Int :~> (Point, Int)
chunkyVars :: Map Point Int -> Map Int Double
mkMap :: Int -> Map Point Int


-- | Template Haskell for discovering all named challenges in a given
--   directory.
module AOC.Discover

-- | Meant to be called like:
--   
--   <pre>
--   mkChallengeMap $$(solutionList "src/AOC/Challenge")
--   </pre>
mkChallengeMap :: [(Finite 25, (Part, SomeSolution))] -> ChallengeMap

-- | Template Haskell splice to produce a list of all named solutions in a
--   directory. Expects solutions as function names following the format
--   <tt>dayDDp</tt>, where <tt>DD</tt> is a two-digit zero-added day, and
--   <tt>p</tt> is a lower-case letter corresponding to the part of the
--   challenge.
--   
--   See <a>mkChallengeMap</a> for a description of usage.
solutionList :: FilePath -> Q (TExp [(Finite 25, (Part, SomeSolution))])

-- | A map of days to parts to solutions.
type ChallengeMap = Map (Finite 25) (Map Part SomeSolution)

-- | A specification for a specific challenge. Should consist of a day and
--   a lowercase character.
data ChallengeSpec
CS :: Finite 25 -> Part -> ChallengeSpec
[_csDay] :: ChallengeSpec -> Finite 25
[_csPart] :: ChallengeSpec -> Part

-- | Turn a day represented by a <tt><a>Finite</a> 25</tt> into an integer
--   day (1 - 25).
dayToInt :: Finite 25 -> Int

-- | Get a <a>ChallengeSpec</a> from a given reified solution (name).
--   
--   <pre>
--   solSpec 'day02a == CS { _csDay = 1, _csPart = <tt>a</tt> }
--   </pre>
solSpec :: Name -> ChallengeSpec

-- | Parse a <a>Literal</a> into a <a>Part</a>
charPart :: Char -> Maybe Part
instance GHC.Classes.Ord AOC.Discover.ChallengeSpec
instance GHC.Classes.Eq AOC.Discover.ChallengeSpec
instance GHC.Show.Show AOC.Discover.ChallengeSpec


-- | Day 12. See <a>AOC.Solver</a> for the types used in this module!
--   
--   After completing the challenge, it is recommended to:
module AOC.Challenge.Day12
day12a :: (IntSet, Set Ctx) :~> Int
day12b :: (IntSet, Set Ctx) :~> Int


-- | Day 10. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day10
day10a :: ([Point], [Point]) :~> Set Lattice
day10b :: ([Point], [Point]) :~> Int

-- | Shift so that centroid is at zero
centralize :: [Point] -> [Point]


-- | Day 9. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day09
day09a :: (Int, Int) :~> Int
day09b :: _ :~> _


-- | Day 8. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day08
day08a :: [Int] :~> Int
day08b :: [Int] :~> Int


-- | Day 7. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day07
day07a :: Map Char (Set Char) :~> String
day07b :: Map Char (Set Char) :~> Natural
instance AOC.Challenge.Day07.HasScheduler (AOC.Challenge.Day07.Scheduler a) a


-- | Day 6. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day06
day06a :: NonEmpty Point :~> Int
day06b :: NonEmpty Point :~> Int


-- | Day 5. See <a>AOC.Solver</a> for the types used in this module!
--   
--   Note that this is slow in the current version of
--   <a>Data.Group.Free</a> on hackage. See
--   <a>https://github.com/mstksg/free-algebras/tree/freegroup2</a> for a
--   version that is efficient.
--   
--   See <a>https://blog.jle.im/entry/alchemical-groups.html</a> for an
--   explaination.
module AOC.Challenge.Day05
day05a :: FreeGroupL Elem :~> Int
day05b :: FreeGroupL Elem :~> Int


-- | Day 4. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day04
day04a :: Map Time Action :~> Int
day04b :: Map Time Action :~> Int
instance GHC.Classes.Ord AOC.Challenge.Day04.Action
instance GHC.Classes.Eq AOC.Challenge.Day04.Action
instance GHC.Show.Show AOC.Challenge.Day04.Action
instance GHC.Classes.Ord AOC.Challenge.Day04.Guard
instance GHC.Classes.Eq AOC.Challenge.Day04.Guard
instance GHC.Show.Show AOC.Challenge.Day04.Guard
instance GHC.Classes.Ord AOC.Challenge.Day04.Time
instance GHC.Classes.Eq AOC.Challenge.Day04.Time
instance GHC.Show.Show AOC.Challenge.Day04.Time


-- | Day 3. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day03

-- | Lends itself pretty well to a functional approach.
--   
--   <ol>
--   <li>Lay the tiles.</li>
--   <li>Get all the frequencies at each time</li>
--   <li>Filter for the frequencies greater than 2</li>
--   <li>Count them</li>
--   </ol>
day03a :: [Rect] :~> Int

-- | Once we lay our tiles, we find the first claim that has no overlaps.
day03b :: [Claim] :~> Int


-- | Day 2. See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day02

-- | We compute a frequency map of all of the characters in a string, and
--   then get all of the frequencies that happened for each line.
--   
--   Then we build a frequency map of the frequencies!
day02a :: [String] :~> Int

-- | The main work is in <a>firstNeighbor</a>, which looks thorugh a list
--   of items and finds the first item whose neighbor was already seen.
--   
--   Then we take the two "almost matching" strings and filter out all of
--   the characters that aren't the same, using <a>zipWith</a> and
--   <a>catMaybes</a>.
day02b :: [String] :~> String


-- | Day 1! See <a>AOC.Solver</a> for the types used in this module!
module AOC.Challenge.Day01

-- | Here we have a basic sum of numbers.
day01a :: [Int] :~> Int

-- | Here we compute a running sum on an infinitely repeated list of
--   inputs, and then use <a>firstRepeated</a> to get the first repeated
--   item in the list of running sums.
day01b :: [Int] :~> Int


-- | Gather together all challenges and collect them into a single map.
module AOC.Challenge

-- | A map of days to parts to solutions.
type ChallengeMap = Map (Finite 25) (Map Part SomeSolution)

-- | A specification for a specific challenge. Should consist of a day and
--   a lowercase character.
data ChallengeSpec
CS :: Finite 25 -> Part -> ChallengeSpec
[_csDay] :: ChallengeSpec -> Finite 25
[_csPart] :: ChallengeSpec -> Part

-- | A given part of a problem. All Advent of Code challenges are
--   two-parts.
--   
--   You can usually get <a>Part1</a> (if it is already released) with a
--   nonsense session key, but <a>Part2</a> always requires a valid session
--   key.
--   
--   Note also that Challenge #25 typically only has a single part.
data Part
Part1 :: Part
Part2 :: Part

-- | A map of all challenges.
challengeMap :: ChallengeMap

-- | Lookup up a solution from a <a>ChallengeMap</a>
lookupSolution :: ChallengeSpec -> Map (Finite 25) (Map Part a) -> Maybe a

-- | Turn a day represented by a <tt><a>Finite</a> 25</tt> into an integer
--   day (1 - 25).
dayToInt :: Finite 25 -> Int

-- | Get a <a>ChallengeSpec</a> from a given reified solution (name).
--   
--   <pre>
--   solSpec 'day02a == CS { _csDay = 1, _csPart = <tt>a</tt> }
--   </pre>
solSpec :: Name -> ChallengeSpec

-- | Parse a <a>Literal</a> into a <a>Part</a>
charPart :: Char -> Maybe Part


-- | Loading challenge data and prompts.
module AOC.Run.Load

-- | A record of paths corresponding to a specific challenge.
data ChallengePaths
CP :: !FilePath -> !FilePath -> !FilePath -> !FilePath -> !FilePath -> ChallengePaths
[_cpPrompt] :: ChallengePaths -> !FilePath
[_cpInput] :: ChallengePaths -> !FilePath
[_cpAnswer] :: ChallengePaths -> !FilePath
[_cpTests] :: ChallengePaths -> !FilePath
[_cpLog] :: ChallengePaths -> !FilePath

-- | Generate a <a>ChallengePaths</a> from a specification of a challenge.
challengePaths :: Integer -> ChallengeSpec -> ChallengePaths

-- | A record of data (test inputs, answers) corresponding to a specific
--   challenge.
data ChallengeData
CD :: !Either [String] Text -> !Either [String] String -> !Maybe String -> ![(String, TestMeta)] -> ChallengeData
[_cdPrompt] :: ChallengeData -> !Either [String] Text
[_cdInput] :: ChallengeData -> !Either [String] String
[_cdAnswer] :: ChallengeData -> !Maybe String
[_cdTests] :: ChallengeData -> ![(String, TestMeta)]

-- | Load data associated with a challenge from a given specification. Will
--   fetch answers online and cache if required (and if giten a session
--   token).
challengeData :: Maybe String -> Integer -> ChallengeSpec -> IO ChallengeData

-- | Run a countdown on the console.
countdownConsole :: MonadIO m => Integer -> Finite 25 -> m a -> m a

-- | Get time until release of a given challenge.
timeToRelease :: Integer -> Finite 25 -> IO NominalDiffTime

-- | Pretty-print a <a>NominalDiffTime</a>
showNominalDiffTime :: NominalDiffTime -> String

-- | Parse a <a>Literal</a> into a <a>Part</a>
charPart :: Char -> Maybe Part
showAoCError :: AoCError -> [String]
htmlToMarkdown :: Bool -> Text -> Either [String] Text
data TestMeta
TM :: Maybe String -> Map String Dynamic -> TestMeta
[_tmAnswer] :: TestMeta -> Maybe String
[_tmData] :: TestMeta -> Map String Dynamic
parseMeta :: Parser TestMeta
parseTests :: Parser [(String, TestMeta)]
instance GHC.Show.Show AOC.Run.Load.MetaLine
instance GHC.Show.Show AOC.Run.Load.TestMeta
instance GHC.Show.Show AOC.Run.Load.ChallengePaths


-- | Run actions regarding challenges, solutions, tests, submissions,
--   viewing prompts, etc.
--   
--   Essentially implements the functionality of the main app.
module AOC.Run

-- | Specification of parts to test and run
data TestSpec
TSAll :: TestSpec
TSDayAll :: Finite 25 -> TestSpec
[_tsDay] :: TestSpec -> Finite 25
TSDayPart :: ChallengeSpec -> TestSpec
[_tsSpec] :: TestSpec -> ChallengeSpec

-- | Options for <a>mainRun</a>.
data MainRunOpts
MRO :: !TestSpec -> !Bool -> !Bool -> !Bool -> !Finite 25 -> Part -> IO (Maybe String) -> MainRunOpts
[_mroSpec] :: MainRunOpts -> !TestSpec

-- | Run tests? (Default: False)
[_mroTest] :: MainRunOpts -> !Bool

-- | Benchmark? (Default: False)
[_mroBench] :: MainRunOpts -> !Bool

-- | Lock in answer as correct? (Default: False)
[_mroLock] :: MainRunOpts -> !Bool

-- | Manually supply input (Default: always return Nothing)
[_mroInput] :: MainRunOpts -> !Finite 25 -> Part -> IO (Maybe String)
class HasMainRunOpts c_a1Hik
mainRunOpts :: HasMainRunOpts c_a1Hik => Lens' c_a1Hik MainRunOpts
mroBench :: HasMainRunOpts c_a1Hik => Lens' c_a1Hik Bool
mroInput :: HasMainRunOpts c_a1Hik => Lens' c_a1Hik (Finite 25 -> Part -> IO (Maybe String))
mroLock :: HasMainRunOpts c_a1Hik => Lens' c_a1Hik Bool
mroSpec :: HasMainRunOpts c_a1Hik => Lens' c_a1Hik TestSpec
mroTest :: HasMainRunOpts c_a1Hik => Lens' c_a1Hik Bool

-- | Run, test, bench.
mainRun :: (MonadIO m, MonadError [String] m) => Config -> MainRunOpts -> m (Map (Finite 25) (Map Part (Maybe Bool, Either [String] String)))

-- | Default options for <a>mainRun</a>.
defaultMRO :: TestSpec -> MainRunOpts

-- | Options for <a>mainView</a>.
data MainViewOpts
MVO :: !TestSpec -> !Bool -> MainViewOpts
[_mvoSpec] :: MainViewOpts -> !TestSpec
[_mvoWait] :: MainViewOpts -> !Bool
class HasMainViewOpts c_a1Hpm
mainViewOpts :: HasMainViewOpts c_a1Hpm => Lens' c_a1Hpm MainViewOpts
mvoSpec :: HasMainViewOpts c_a1Hpm => Lens' c_a1Hpm TestSpec
mvoWait :: HasMainViewOpts c_a1Hpm => Lens' c_a1Hpm Bool

-- | View prompt
mainView :: (MonadIO m, MonadError [String] m) => Config -> MainViewOpts -> m (Map (Finite 25) (Map Part Text))

-- | Default options for <a>mainView</a>.
defaultMVO :: TestSpec -> MainViewOpts

-- | Options for <a>mainSubmit</a>
data MainSubmitOpts
MSO :: !ChallengeSpec -> !Bool -> !Bool -> !Bool -> MainSubmitOpts
[_msoSpec] :: MainSubmitOpts -> !ChallengeSpec

-- | Run tests before submitting? (Default: True)
[_msoTest] :: MainSubmitOpts -> !Bool

-- | Force submission even if bad? (Default: False)
[_msoForce] :: MainSubmitOpts -> !Bool

-- | Lock answer if submission succeeded? (Default: True)
[_msoLock] :: MainSubmitOpts -> !Bool
class HasMainSubmitOpts c_a1HtF
mainSubmitOpts :: HasMainSubmitOpts c_a1HtF => Lens' c_a1HtF MainSubmitOpts
msoForce :: HasMainSubmitOpts c_a1HtF => Lens' c_a1HtF Bool
msoLock :: HasMainSubmitOpts c_a1HtF => Lens' c_a1HtF Bool
msoSpec :: HasMainSubmitOpts c_a1HtF => Lens' c_a1HtF ChallengeSpec
msoTest :: HasMainSubmitOpts c_a1HtF => Lens' c_a1HtF Bool

-- | Submit and analyze result
mainSubmit :: (MonadIO m, MonadError [String] m) => Config -> MainSubmitOpts -> m (Text, SubmitRes)

-- | Default options for <a>mainSubmit</a>.
defaultMSO :: ChallengeSpec -> MainSubmitOpts

-- | Do the action with a given ANSI foreground color and intensity.
withColor :: ColorIntensity -> Color -> IO () -> IO ()
instance AOC.Run.HasMainSubmitOpts AOC.Run.MainSubmitOpts
instance GHC.Show.Show AOC.Run.MainSubmitOpts
instance AOC.Run.HasMainViewOpts AOC.Run.MainViewOpts
instance GHC.Show.Show AOC.Run.MainViewOpts
instance AOC.Run.HasMainRunOpts AOC.Run.MainRunOpts
instance GHC.Show.Show AOC.Run.TestSpec


-- | Versions of loaders and runners meant to be used in GHCI.
module AOC.Run.Interactive

-- | Run the solution indicated by the challenge spec on the official
--   puzzle input. Get answer as result.
execSolution :: ChallengeSpec -> IO String

-- | Run the solution indicated by the challenge spec on a custom input.
--   Get answer as result.
execSolutionWith :: ChallengeSpec -> String -> IO String

-- | Run test suite for a given challenge spec.
--   
--   Returns <a>Just</a> if any tests were run, with a <a>Bool</a>
--   specifying whether or not all tests passed.
testSolution :: ChallengeSpec -> IO (Maybe Bool)

-- | View the prompt for a given challenge spec.
viewPrompt :: ChallengeSpec -> IO Text

-- | Countdown to get the prompt for a given challenge spec, if not yet
--   available.
waitForPrompt :: ChallengeSpec -> IO Text

-- | Submit solution for a given challenge spec, and lock if correct.
submitSolution :: ChallengeSpec -> IO (Text, SubmitRes)

-- | Result-suppressing version of <a>execSolution</a>.
execSolution_ :: ChallengeSpec -> IO ()

-- | Result-suppressing version of <a>execSolutionWith</a>.
execSolutionWith_ :: ChallengeSpec -> String -> IO ()

-- | Result-suppressing version of <a>testSolution</a>.
testSolution_ :: ChallengeSpec -> IO ()

-- | Result-suppressing version of <a>viewPrompt</a>.
viewPrompt_ :: ChallengeSpec -> IO ()

-- | Result-suppressing version of <a>waitForPrompt</a>.
waitForPrompt_ :: ChallengeSpec -> IO ()

-- | Result-suppressing version of <a>submitSolution</a>.
submitSolution_ :: ChallengeSpec -> IO ()

-- | Load input for a given challenge
loadInput :: ChallengeSpec -> IO String

-- | Load test cases for a given challenge
loadTests :: ChallengeSpec -> IO [(String, TestMeta)]

-- | Unsafely create a <a>ChallengeSpec</a> from a day number and part.
--   
--   Is undefined if given a day number out of range (1-25).
mkSpec :: Integer -> Part -> ChallengeSpec


-- | Single-stop entry point for the library's functionality and all
--   challenge solutions.
module AOC
